var tipuesearch = {"pages":[{"title":" finterp ","text":"finterp FINTERP: Multidimensional Linear Interpolation with Modern Fortran Status Description Can be used to perform multidimensional (1D-6D) linear interpolation of data on a regular grid. The code is written in modern Fortran (2003/2008) and is object-oriented and thread safe. Usage There are six classes ( linear_interp_1d , linear_interp_2d , linear_interp_3d , linear_interp_4d , linear_interp_5d , and linear_interp_6d ). Each has three methods: initialize , evaluate , and destroy . real ( wp ) :: x ( nx ), y ( ny ), z ( nz ), q ( nq ), r ( nr ), s ( ns ) real ( wp ) :: fcn_1d ( nx ) real ( wp ) :: fcn_2d ( nx , ny ) real ( wp ) :: fcn_3d ( nx , ny , nz ) real ( wp ) :: fcn_4d ( nx , ny , nz , nq ) real ( wp ) :: fcn_5d ( nx , ny , nz , nq , nr ) real ( wp ) :: fcn_6d ( nx , ny , nz , nq , nr , ns ) real ( wp ) :: xval , yval , zval , qval , rval , sval , fval integer :: iflag type ( linear_interp_1d ) :: s1 type ( linear_interp_2d ) :: s2 type ( linear_interp_3d ) :: s3 type ( linear_interp_4d ) :: s4 type ( linear_interp_5d ) :: s5 type ( linear_interp_6d ) :: s6 !populate the arrays !... !initialize the class: call s1 % initialize ( x , fcn_1d , iflag ) call s2 % initialize ( x , y , fcn_2d , iflag ) call s3 % initialize ( x , y , z , fcn_3d , iflag ) call s4 % initialize ( x , y , z , q , fcn_4d , iflag ) call s5 % initialize ( x , y , z , q , r , fcn_5d , iflag ) call s6 % initialize ( x , y , z , q , r , s , fcn_6d , iflag ) !interpolate: call s1 % evaluate ( xval , fval ) call s2 % evaluate ( xval , yval , fval ) call s3 % evaluate ( xval , yval , zval , fval ) call s4 % evaluate ( xval , yval , zval , qval , fval ) call s5 % evaluate ( xval , yval , zval , qval , rval , fval ) call s6 % evaluate ( xval , yval , zval , qval , rval , sval , fval ) !free memory: call s1 % destroy () call s2 % destroy () call s3 % destroy () call s4 % destroy () call s5 % destroy () call s6 % destroy () Nearest Neighbor Interpolation The library also includes classes for nearest neighbor interpolation ( nearest_interp_1d , nearest_interp_2d , ...). The interfaces are the same as for the linear classes. Documentation The latest API documentation can be found here . This was generated from the source code using FORD (note that the included build.sh script will also generate these files). License The finterp source code and related files and documentation are distributed under a permissive free software license (BSD-style). See also bspline-fortran , B-spline interpolation. PCHIP , Piecewise Cubic Hermite Interpolation. Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"linear_interpolation_module.f90 â€“ finterp","text":"Contents Modules linear_interpolation_module Source Code linear_interpolation_module.f90 Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  Multidimensional linear interpolation/extrapolation. ! !  Uses repeated linear interpolation to evaluate !  functions f(x), f(x,y), f(x,y,z), f(x,y,z,q), f(x,y,z,q,r), f(x,y,z,q,r,s)  !  which have been tabulated at the nodes of an n-dimensional rectangular grid. !  If any coordinate  (x_i, y_i, ...)  lies outside the range of the corresponding !  variable, then extrapolation is performed using the two nearest points. module linear_interpolation_module use iso_fortran_env , only : wp => real64 ! working precision implicit none private real ( wp ), parameter , private :: zero = 0.0_wp !! numeric constant real ( wp ), parameter , private :: one = 1.0_wp !! numeric constant type , public , abstract :: linear_interp_class !! Base class for the linear interpolation types private logical :: initialized = . false . !! if the class was properly initialized contains private procedure ( destroy_func ), deferred , public :: destroy !! destructor procedure :: check_inputs end type linear_interp_class abstract interface pure elemental subroutine destroy_func ( me ) !! interface for bspline destructor routines import :: linear_interp_class implicit none class ( linear_interp_class ), intent ( inout ) :: me end subroutine destroy_func end interface type , extends ( linear_interp_class ), public :: linear_interp_1d !! Class for 1d linear interpolation. private real ( wp ), dimension (:), allocatable :: f real ( wp ), dimension (:), allocatable :: x integer :: ilox = 1 contains private procedure , public :: initialize => initialize_1d procedure , public :: evaluate => interp_1d procedure , public :: destroy => destroy_1d final :: finalize_1d end type linear_interp_1d type , extends ( linear_interp_class ), public :: linear_interp_2d !! Class for 2d linear interpolation. private real ( wp ), dimension (:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y integer :: ilox = 1 integer :: iloy = 1 contains private procedure , public :: initialize => initialize_2d procedure , public :: evaluate => interp_2d procedure , public :: destroy => destroy_2d final :: finalize_2d end type linear_interp_2d type , extends ( linear_interp_class ), public :: linear_interp_3d !! Class for 3d linear interpolation. private real ( wp ), dimension (:,:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y real ( wp ), dimension (:), allocatable :: z integer :: ilox = 1 integer :: iloy = 1 integer :: iloz = 1 contains private procedure , public :: initialize => initialize_3d procedure , public :: evaluate => interp_3d procedure , public :: destroy => destroy_3d final :: finalize_3d end type linear_interp_3d type , extends ( linear_interp_class ), public :: linear_interp_4d !! Class for 4d linear interpolation. private real ( wp ), dimension (:,:,:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y real ( wp ), dimension (:), allocatable :: z real ( wp ), dimension (:), allocatable :: q integer :: ilox = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 contains private procedure , public :: initialize => initialize_4d procedure , public :: evaluate => interp_4d procedure , public :: destroy => destroy_4d final :: finalize_4d end type linear_interp_4d type , extends ( linear_interp_class ), public :: linear_interp_5d !! Class for 5d linear interpolation. private real ( wp ), dimension (:,:,:,:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y real ( wp ), dimension (:), allocatable :: z real ( wp ), dimension (:), allocatable :: q real ( wp ), dimension (:), allocatable :: r integer :: ilox = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 integer :: ilor = 1 contains private procedure , public :: initialize => initialize_5d procedure , public :: evaluate => interp_5d procedure , public :: destroy => destroy_5d final :: finalize_5d end type linear_interp_5d type , extends ( linear_interp_class ), public :: linear_interp_6d !! Class for 6d linear interpolation. private real ( wp ), dimension (:,:,:,:,:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y real ( wp ), dimension (:), allocatable :: z real ( wp ), dimension (:), allocatable :: q real ( wp ), dimension (:), allocatable :: r real ( wp ), dimension (:), allocatable :: s integer :: ilox = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 integer :: ilor = 1 integer :: ilos = 1 contains private procedure , public :: initialize => initialize_6d procedure , public :: evaluate => interp_6d procedure , public :: destroy => destroy_6d final :: finalize_6d end type linear_interp_6d type , extends ( linear_interp_1d ), public :: nearest_interp_1d !! Class for 1d nearest neighbor interpolation. contains procedure , public :: evaluate => nearest_1d end type nearest_interp_1d type , extends ( linear_interp_2d ), public :: nearest_interp_2d !! Class for 2d nearest neighbor interpolation. contains procedure , public :: evaluate => nearest_2d end type nearest_interp_2d type , extends ( linear_interp_3d ), public :: nearest_interp_3d !! Class for 3d nearest neighbor interpolation. contains procedure , public :: evaluate => nearest_3d end type nearest_interp_3d type , extends ( linear_interp_4d ), public :: nearest_interp_4d !! Class for 4d nearest neighbor interpolation. contains procedure , public :: evaluate => nearest_4d end type nearest_interp_4d type , extends ( linear_interp_5d ), public :: nearest_interp_5d !! Class for 5d nearest neighbor interpolation. contains procedure , public :: evaluate => nearest_5d end type nearest_interp_5d type , extends ( linear_interp_6d ), public :: nearest_interp_6d !! Class for 6d nearest neighbor interpolation. contains procedure , public :: evaluate => nearest_6d end type nearest_interp_6d contains !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for a [[linear_interp_1d]] type. pure elemental subroutine finalize_1d ( me ) implicit none type ( linear_interp_1d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_1d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for a [[linear_interp_2d]] type. pure elemental subroutine finalize_2d ( me ) implicit none type ( linear_interp_2d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_2d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for a [[linear_interp_3d]] type. pure elemental subroutine finalize_3d ( me ) implicit none type ( linear_interp_3d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_3d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for a [[linear_interp_4d]] type. pure elemental subroutine finalize_4d ( me ) implicit none type ( linear_interp_4d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_4d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for a [[linear_interp_5d]] type. pure elemental subroutine finalize_5d ( me ) implicit none type ( linear_interp_5d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_5d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for a [[linear_interp_6d]] type. pure elemental subroutine finalize_6d ( me ) implicit none type ( linear_interp_6d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_6d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for a [[linear_interp_1d]] class. pure elemental subroutine destroy_1d ( me ) implicit none class ( linear_interp_1d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) me % ilox = 1 me % initialized = . false . end subroutine destroy_1d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for a [[linear_interp_2d]] class. pure elemental subroutine destroy_2d ( me ) implicit none class ( linear_interp_2d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) me % ilox = 1 me % iloy = 1 me % initialized = . false . end subroutine destroy_2d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for a [[linear_interp_3d]] class. pure elemental subroutine destroy_3d ( me ) implicit none class ( linear_interp_3d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) if ( allocated ( me % z )) deallocate ( me % z ) me % ilox = 1 me % iloy = 1 me % iloz = 1 me % initialized = . false . end subroutine destroy_3d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for a [[linear_interp_4d]] class. pure elemental subroutine destroy_4d ( me ) implicit none class ( linear_interp_4d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) if ( allocated ( me % z )) deallocate ( me % z ) if ( allocated ( me % q )) deallocate ( me % q ) me % ilox = 1 me % iloy = 1 me % iloz = 1 me % iloq = 1 me % initialized = . false . end subroutine destroy_4d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for a [[linear_interp_5d]] class. pure elemental subroutine destroy_5d ( me ) implicit none class ( linear_interp_5d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) if ( allocated ( me % z )) deallocate ( me % z ) if ( allocated ( me % q )) deallocate ( me % q ) if ( allocated ( me % r )) deallocate ( me % r ) me % ilox = 1 me % iloy = 1 me % iloz = 1 me % iloq = 1 me % ilor = 1 me % initialized = . false . end subroutine destroy_5d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for a [[linear_interp_6d]] class. pure elemental subroutine destroy_6d ( me ) implicit none class ( linear_interp_6d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) if ( allocated ( me % z )) deallocate ( me % z ) if ( allocated ( me % q )) deallocate ( me % q ) if ( allocated ( me % r )) deallocate ( me % r ) if ( allocated ( me % s )) deallocate ( me % s ) me % ilox = 1 me % iloy = 1 me % iloz = 1 me % iloq = 1 me % ilor = 1 me % ilos = 1 me % initialized = . false . end subroutine destroy_6d !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[linear_interp_1d]] class. pure subroutine initialize_1d ( me , x , f , istat ) implicit none class ( linear_interp_1d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`   : no problems, !! `1`   : `x` is not strictly increasing, !! `10`  : `x` is not equal to size(f,1), !! `100` : cannot use linear interpolation for only one point. call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 ) then call me % check_inputs ( x = x , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x me % initialized = . true . end if end if end subroutine initialize_1d !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[linear_interp_2d]] class. pure subroutine initialize_2d ( me , x , y , f , istat ) implicit none class ( linear_interp_2d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`   : no problems, !! `1`   : `x` is not strictly increasing, !! `2`   : `y` is not strictly increasing, !! `10`  : `x` is not equal to size(f,1), !! `20`  : `y` is not equal to size(f,2), !! `100` : cannot use linear interpolation for only one point. call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 ) then call me % check_inputs ( x = x , y = y , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y me % initialized = . true . end if end if end subroutine initialize_2d !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[linear_interp_3d]] class. pure subroutine initialize_3d ( me , x , y , z , f , istat ) implicit none class ( linear_interp_3d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:,:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`   : no problems, !! `1`   : `x` is not strictly increasing, !! `2`   : `y` is not strictly increasing, !! `3`   : `z` is not strictly increasing, !! `10`  : `x` is not equal to size(f,1), !! `20`  : `y` is not equal to size(f,2), !! `30`  : `z` is not equal to size(f,3), !! `100` : cannot use linear interpolation for only one point. call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 . and . size ( z ) /= size ( f , 3 )) istat = 30 if ( istat == 0 ) then call me % check_inputs ( x = x , y = y , z = z , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ), size ( z ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y allocate ( me % z ( size ( z ))); me % z = z me % initialized = . true . end if end if end subroutine initialize_3d !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[linear_interp_4d]] class. pure subroutine initialize_4d ( me , x , y , z , q , f , istat ) implicit none class ( linear_interp_4d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:,:,:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`   : no problems, !! `1`   : `x` is not strictly increasing, !! `2`   : `y` is not strictly increasing, !! `3`   : `z` is not strictly increasing, !! `4`   : `q` is not strictly increasing, !! `10`  : `x` is not equal to size(f,1), !! `20`  : `y` is not equal to size(f,2), !! `30`  : `z` is not equal to size(f,3), !! `40`  : `q` is not equal to size(f,4), !! `100` : cannot use linear interpolation for only one point. call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 . and . size ( z ) /= size ( f , 3 )) istat = 30 if ( istat == 0 . and . size ( q ) /= size ( f , 4 )) istat = 40 if ( istat == 0 ) then call me % check_inputs ( x = x , y = y , z = z , q = q , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ), size ( z ), size ( q ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y allocate ( me % z ( size ( z ))); me % z = z allocate ( me % q ( size ( q ))); me % q = q me % initialized = . true . end if end if end subroutine initialize_4d !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[linear_interp_5d]] class. pure subroutine initialize_5d ( me , x , y , z , q , r , f , istat ) implicit none class ( linear_interp_5d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:,:,:,:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`   : no problems, !! `1`   : `x` is not strictly increasing, !! `2`   : `y` is not strictly increasing, !! `3`   : `z` is not strictly increasing, !! `4`   : `q` is not strictly increasing, !! `5`   : `r` is not strictly increasing, !! `10`  : `x` is not equal to size(f,1), !! `20`  : `y` is not equal to size(f,2), !! `30`  : `z` is not equal to size(f,3), !! `40`  : `q` is not equal to size(f,4), !! `50`  : `r` is not equal to size(f,5), !! `100` : cannot use linear interpolation for only one point. call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 . and . size ( z ) /= size ( f , 3 )) istat = 30 if ( istat == 0 . and . size ( q ) /= size ( f , 4 )) istat = 40 if ( istat == 0 . and . size ( r ) /= size ( f , 5 )) istat = 50 if ( istat == 0 ) then call me % check_inputs ( x = x , y = y , z = z , q = q , r = r , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ), size ( z ), size ( q ), size ( r ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y allocate ( me % z ( size ( z ))); me % z = z allocate ( me % q ( size ( q ))); me % q = q allocate ( me % r ( size ( r ))); me % r = r me % initialized = . true . end if end if end subroutine initialize_5d !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[linear_interp_6d]] class. pure subroutine initialize_6d ( me , x , y , z , q , r , s , f , istat ) implicit none class ( linear_interp_6d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:), intent ( in ) :: s real ( wp ), dimension (:,:,:,:,:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`   : no problems, !! `1`   : `x` is not strictly increasing, !! `2`   : `y` is not strictly increasing, !! `3`   : `z` is not strictly increasing, !! `4`   : `q` is not strictly increasing, !! `5`   : `r` is not strictly increasing, !! `6`   : `s` is not strictly increasing, !! `10`  : `x` is not equal to size(f,1), !! `20`  : `y` is not equal to size(f,2), !! `30`  : `z` is not equal to size(f,3), !! `40`  : `q` is not equal to size(f,4), !! `50`  : `r` is not equal to size(f,5), !! `60`  : `s` is not equal to size(f,6), !! `100` : cannot use linear interpolation for only one point. call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 . and . size ( z ) /= size ( f , 3 )) istat = 30 if ( istat == 0 . and . size ( q ) /= size ( f , 4 )) istat = 40 if ( istat == 0 . and . size ( r ) /= size ( f , 5 )) istat = 50 if ( istat == 0 . and . size ( s ) /= size ( f , 6 )) istat = 60 if ( istat == 0 ) then call me % check_inputs ( x = x , y = y , z = z , q = q , r = r , s = s , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ), size ( z ), size ( q ), size ( r ), size ( s ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y allocate ( me % z ( size ( z ))); me % z = z allocate ( me % q ( size ( q ))); me % q = q allocate ( me % r ( size ( r ))); me % r = r allocate ( me % s ( size ( s ))); me % s = s me % initialized = . true . end if end if end subroutine initialize_6d !***************************************************************************************** !***************************************************************************************** !> !  1D linear interpolation routine. pure subroutine interp_1d ( me , x , f , istat ) implicit none class ( linear_interp_1d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( out ) :: f !! Interpolated  f(x)  integer , intent ( out ), optional :: istat !! `0`  : no problems, !! `-1` : class has not been initialized integer , dimension ( 2 ) :: ix real ( wp ) :: p1 real ( wp ) :: q1 integer :: mflag if ( me % initialized ) then call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) p1 = one - q1 f = p1 * me % f ( ix ( 1 )) + q1 * me % f ( ix ( 2 )) if ( present ( istat )) istat = 0 else if ( present ( istat )) istat = - 1 f = zero end if end subroutine interp_1d !***************************************************************************************** !***************************************************************************************** !> !  2D linear interpolation routine. pure subroutine interp_2d ( me , x , y , f , istat ) implicit none class ( linear_interp_2d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( out ) :: f !! Interpolated  f(x,y)  integer , intent ( out ), optional :: istat !! `0`  : no problems, !! `-1` : class has not been initialized integer , dimension ( 2 ) :: ix , iy real ( wp ) :: p1 , p2 real ( wp ) :: q1 , q2 integer :: mflag real ( wp ) :: fx1 , fx2 if ( me % initialized ) then call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) p1 = one - q1 p2 = one - q2 fx1 = p1 * me % f ( ix ( 1 ), iy ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 )) fx2 = p1 * me % f ( ix ( 1 ), iy ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 )) f = p2 * fx1 + q2 * fx2 if ( present ( istat )) istat = 0 else if ( present ( istat )) istat = - 1 f = zero end if end subroutine interp_2d !***************************************************************************************** !***************************************************************************************** !> !  3D linear interpolation routine. pure subroutine interp_3d ( me , x , y , z , f , istat ) implicit none class ( linear_interp_3d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( out ) :: f !! Interpolated  f(x,y,z)  integer , intent ( out ), optional :: istat !! `0`  : no problems, !! `-1` : class has not been initialized integer , dimension ( 2 ) :: ix , iy , iz real ( wp ) :: p1 , p2 , p3 real ( wp ) :: q1 , q2 , q3 integer :: mflag real ( wp ) :: fx11 , fx21 , fx12 , fx22 , fxy1 , fxy2 if ( me % initialized ) then call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) q3 = ( z - me % z ( iz ( 1 ))) / ( me % z ( iz ( 2 )) - me % z ( iz ( 1 ))) p1 = one - q1 p2 = one - q2 p3 = one - q3 fx11 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 )) fx21 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 )) fx12 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 )) fx22 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 )) fxy1 = p2 * fx11 + q2 * fx21 fxy2 = p2 * fx12 + q2 * fx22 f = p3 * fxy1 + q3 * fxy2 if ( present ( istat )) istat = 0 else if ( present ( istat )) istat = - 1 f = zero end if end subroutine interp_3d !***************************************************************************************** !***************************************************************************************** !> !  4D linear interpolation routine. pure subroutine interp_4d ( me , x , y , z , q , f , istat ) implicit none class ( linear_interp_4d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( in ) :: q real ( wp ), intent ( out ) :: f !! Interpolated  f(x,y,z,q)  integer , intent ( out ), optional :: istat !! `0`  : no problems, !! `-1` : class has not been initialized integer , dimension ( 2 ) :: ix , iy , iz , iq real ( wp ) :: p1 , p2 , p3 , p4 real ( wp ) :: q1 , q2 , q3 , q4 integer :: mflag real ( wp ) :: fx111 , fx211 , fx121 , fx221 , fxy11 , fxy21 , fxyz1 ,& fx112 , fx212 , fx122 , fx222 , fxy12 , fxy22 , fxyz2 if ( me % initialized ) then call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag ) call dintrv ( me % q , q , me % iloq , iq ( 1 ), iq ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) q3 = ( z - me % z ( iz ( 1 ))) / ( me % z ( iz ( 2 )) - me % z ( iz ( 1 ))) q4 = ( q - me % q ( iq ( 1 ))) / ( me % q ( iq ( 2 )) - me % q ( iq ( 1 ))) p1 = one - q1 p2 = one - q2 p3 = one - q3 p4 = one - q4 fx111 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 )) fx211 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 )) fx121 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 )) fx221 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 )) fx112 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 )) fx212 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 )) fx122 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 )) fx222 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 )) fxy11 = p2 * fx111 + q2 * fx211 fxy21 = p2 * fx121 + q2 * fx221 fxy12 = p2 * fx112 + q2 * fx212 fxy22 = p2 * fx122 + q2 * fx222 fxyz1 = p3 * fxy11 + q3 * fxy21 fxyz2 = p3 * fxy12 + q3 * fxy22 f = p4 * fxyz1 + q4 * fxyz2 if ( present ( istat )) istat = 0 else if ( present ( istat )) istat = - 1 f = zero end if end subroutine interp_4d !***************************************************************************************** !***************************************************************************************** !> !  5D linear interpolation routine. pure subroutine interp_5d ( me , x , y , z , q , r , f , istat ) implicit none class ( linear_interp_5d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( in ) :: q real ( wp ), intent ( in ) :: r real ( wp ), intent ( out ) :: f !! Interpolated  f(x,y,z,q,r)  integer , intent ( out ), optional :: istat !! `0`  : no problems, !! `-1` : class has not been initialized integer , dimension ( 2 ) :: ix , iy , iz , iq , ir real ( wp ) :: p1 , p2 , p3 , p4 , p5 real ( wp ) :: q1 , q2 , q3 , q4 , q5 integer :: mflag real ( wp ) :: fx1111 , fx2111 , fx1211 , fx2211 , fx1121 , fx2121 , fx1221 , fx2221 , & fxy111 , fxy211 , fxy121 , fxy221 , fxyz11 , fxyz21 , fxyzq1 , fx1112 , & fx2112 , fx1212 , fx2212 , fx1122 , fx2122 , fx1222 , fx2222 , fxy112 , & fxy212 , fxy122 , fxy222 , fxyz12 , fxyz22 , fxyzq2 if ( me % initialized ) then call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag ) call dintrv ( me % q , q , me % iloq , iq ( 1 ), iq ( 2 ), mflag ) call dintrv ( me % r , r , me % ilor , ir ( 1 ), ir ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) q3 = ( z - me % z ( iz ( 1 ))) / ( me % z ( iz ( 2 )) - me % z ( iz ( 1 ))) q4 = ( q - me % q ( iq ( 1 ))) / ( me % q ( iq ( 2 )) - me % q ( iq ( 1 ))) q5 = ( r - me % r ( ir ( 1 ))) / ( me % r ( ir ( 2 )) - me % r ( ir ( 1 ))) p1 = one - q1 p2 = one - q2 p3 = one - q3 p4 = one - q4 p5 = one - q5 fx1111 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 )) fx2111 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 )) fx1211 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 )) fx2211 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 )) fx1121 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 )) fx2121 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 )) fx1221 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 )) fx2221 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 )) fx1112 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 )) fx2112 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 )) fx1212 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 )) fx2212 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 )) fx1122 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 )) fx2122 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 )) fx1222 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 )) fx2222 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 )) fxy111 = p2 * fx1111 + q2 * fx2111 fxy211 = p2 * fx1211 + q2 * fx2211 fxy121 = p2 * fx1121 + q2 * fx2121 fxy221 = p2 * fx1221 + q2 * fx2221 fxy112 = p2 * fx1112 + q2 * fx2112 fxy212 = p2 * fx1212 + q2 * fx2212 fxy122 = p2 * fx1122 + q2 * fx2122 fxy222 = p2 * fx1222 + q2 * fx2222 fxyz11 = p3 * fxy111 + q3 * fxy211 fxyz21 = p3 * fxy121 + q3 * fxy221 fxyz12 = p3 * fxy112 + q3 * fxy212 fxyz22 = p3 * fxy122 + q3 * fxy222 fxyzq1 = p4 * fxyz11 + q4 * fxyz21 fxyzq2 = p4 * fxyz12 + q4 * fxyz22 f = p5 * fxyzq1 + q5 * fxyzq2 if ( present ( istat )) istat = 0 else if ( present ( istat )) istat = - 1 f = zero end if end subroutine interp_5d !***************************************************************************************** !***************************************************************************************** !> !  6D linear interpolation routine. pure subroutine interp_6d ( me , x , y , z , q , r , s , f , istat ) implicit none class ( linear_interp_6d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( in ) :: q real ( wp ), intent ( in ) :: r real ( wp ), intent ( in ) :: s real ( wp ), intent ( out ) :: f !! Interpolated  f(x,y,z,q,r,s)  integer , intent ( out ), optional :: istat !! `0`  : no problems, !! `-1` : class has not been initialized integer , dimension ( 2 ) :: ix , iy , iz , iq , ir , is real ( wp ) :: p1 , p2 , p3 , p4 , p5 , p6 real ( wp ) :: q1 , q2 , q3 , q4 , q5 , q6 integer :: mflag real ( wp ) :: fx11111 , fx21111 , fx12111 , fx22111 , fx11211 , fx21211 , fx12211 , & fx22211 , fxy1111 , fxy2111 , fxy1211 , fxy2211 , fxyz111 , fxyz211 , & fxyzq11 , fx11121 , fx21121 , fx12121 , fx22121 , fx11221 , fx21221 , & fx12221 , fx22221 , fxy1121 , fxy2121 , fxy1221 , fxy2221 , fxyz121 , & fxyz221 , fxyzq21 , fx11112 , fx21112 , fx12112 , fx22112 , fx11212 , & fx21212 , fx12212 , fx22212 , fxy1112 , fxy2112 , fxy1212 , fxy2212 , & fxyz112 , fxyz212 , fxyzq12 , fx11122 , fx21122 , fx12122 , fx22122 , & fx11222 , fx21222 , fx12222 , fx22222 , fxy1122 , fxy2122 , fxy1222 , & fxy2222 , fxyz122 , fxyz222 , fxyzq22 , fxyzqr1 , fxyzqr2 if ( me % initialized ) then call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag ) call dintrv ( me % q , q , me % iloq , iq ( 1 ), iq ( 2 ), mflag ) call dintrv ( me % r , r , me % ilor , ir ( 1 ), ir ( 2 ), mflag ) call dintrv ( me % s , s , me % ilos , is ( 1 ), is ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) q3 = ( z - me % z ( iz ( 1 ))) / ( me % z ( iz ( 2 )) - me % z ( iz ( 1 ))) q4 = ( q - me % q ( iq ( 1 ))) / ( me % q ( iq ( 2 )) - me % q ( iq ( 1 ))) q5 = ( r - me % r ( ir ( 1 ))) / ( me % r ( ir ( 2 )) - me % r ( ir ( 1 ))) q6 = ( s - me % s ( is ( 1 ))) / ( me % s ( is ( 2 )) - me % s ( is ( 1 ))) p1 = one - q1 p2 = one - q2 p3 = one - q3 p4 = one - q4 p5 = one - q5 p6 = one - q6 fx11111 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 1 )) fx21111 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 1 )) fx12111 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 1 )) fx22111 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 1 )) fx11211 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 1 )) fx21211 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 1 )) fx12211 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 1 )) fx22211 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 1 )) fx11121 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 1 )) fx21121 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 1 )) fx12121 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 1 )) fx22121 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 1 )) fx11221 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 1 )) fx21221 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 1 )) fx12221 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 1 )) fx22221 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 1 )) fx11112 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 2 )) fx21112 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 2 )) fx12112 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 2 )) fx22112 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 2 )) fx11212 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 2 )) fx21212 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 2 )) fx12212 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 2 )) fx22212 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 2 )) fx11122 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 2 )) fx21122 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 2 )) fx12122 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 2 )) fx22122 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 2 )) fx11222 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 2 )) fx21222 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 2 )) fx12222 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 2 )) fx22222 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 2 )) fxy1111 = p2 * fx11111 + q2 * fx21111 fxy2111 = p2 * fx12111 + q2 * fx22111 fxy1211 = p2 * fx11211 + q2 * fx21211 fxy2211 = p2 * fx12211 + q2 * fx22211 fxy1121 = p2 * fx11121 + q2 * fx21121 fxy2121 = p2 * fx12121 + q2 * fx22121 fxy1221 = p2 * fx11221 + q2 * fx21221 fxy2221 = p2 * fx12221 + q2 * fx22221 fxy1112 = p2 * fx11112 + q2 * fx21112 fxy2112 = p2 * fx12112 + q2 * fx22112 fxy1212 = p2 * fx11212 + q2 * fx21212 fxy2212 = p2 * fx12212 + q2 * fx22212 fxy1122 = p2 * fx11122 + q2 * fx21122 fxy2122 = p2 * fx12122 + q2 * fx22122 fxy1222 = p2 * fx11222 + q2 * fx21222 fxy2222 = p2 * fx12222 + q2 * fx22222 fxyz111 = p3 * fxy1111 + q3 * fxy2111 fxyz211 = p3 * fxy1211 + q3 * fxy2211 fxyz121 = p3 * fxy1121 + q3 * fxy2121 fxyz221 = p3 * fxy1221 + q3 * fxy2221 fxyz112 = p3 * fxy1112 + q3 * fxy2112 fxyz212 = p3 * fxy1212 + q3 * fxy2212 fxyz122 = p3 * fxy1122 + q3 * fxy2122 fxyz222 = p3 * fxy1222 + q3 * fxy2222 fxyzq11 = p4 * fxyz111 + q4 * fxyz211 fxyzq21 = p4 * fxyz121 + q4 * fxyz221 fxyzq12 = p4 * fxyz112 + q4 * fxyz212 fxyzq22 = p4 * fxyz122 + q4 * fxyz222 fxyzqr1 = p5 * fxyzq11 + q5 * fxyzq21 fxyzqr2 = p5 * fxyzq12 + q5 * fxyzq22 f = p6 * fxyzqr1 + q6 * fxyzqr2 if ( present ( istat )) istat = 0 else if ( present ( istat )) istat = - 1 f = zero end if end subroutine interp_6d !***************************************************************************************** !***************************************************************************************** !> !  Returns the indices in `xt` that bound `x`, to use for interpolation. !  If outside the range, then the indices are returned that can !  be used for extrapolation. !  Precisely, ! !```fortran !         if            x < xt(1)   then ileft=1,   iright=2,    mflag=-1 !         if   xt(i) <= x < xt(i+1) then ileft=i,   iright=i+1,  mflag=0 !         if   xt(n) <= x           then ileft=n-1, iright=n,    mflag=1 !``` ! !### History ! !  * interv written by carl de boor [5] !  * dintrv author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * Jacob Williams, 2/24/2015 : updated to free-form Fortran. !  * Jacob Williams, 2/17/2016 : additional refactoring (eliminated GOTOs). !  * Jacob Williams, 2/22/2016 : modified bspline-fortran `dintrv` routine for !    linear interpolation/extrapolation use. !  * Jacob Williams, 10/9/2019 : added optional `inearest` output. pure subroutine dintrv ( xt , x , ilo , ileft , iright , mflag , inearest ) implicit none real ( wp ), dimension (:), intent ( in ) :: xt !! a knot or break point vector real ( wp ), intent ( in ) :: x !! argument integer , intent ( inout ) :: ilo !! an initialization parameter which must be set !! to 1 the first time the array `xt` is !! processed by dintrv. `ilo` contains information for !! efficient processing after the initial call and `ilo` !! must not be changed by the user.  each dimension !! requires a distinct `ilo` parameter. integer , intent ( out ) :: ileft !! left index integer , intent ( out ) :: iright !! right index integer , intent ( out ) :: mflag !! signals when `x` lies out of bounds integer , intent ( out ), optional :: inearest !! nearest index integer :: ihi , istep , imid , n n = size ( xt ) if ( n == 1 ) then ! this is only allowed for nearest interpolation if ( present ( inearest )) then inearest = 1 return end if end if ihi = ilo + 1 if ( ihi >= n ) then if ( x >= xt ( n ) ) then mflag = 1 ileft = n - 1 iright = n if ( present ( inearest )) inearest = n return end if if ( n <= 1 ) then mflag = - 1 ileft = 1 iright = 2 if ( present ( inearest )) inearest = 1 return end if ilo = n - 1 ihi = n endif if ( x >= xt ( ihi ) ) then ! now x >= xt(ilo). find upper bound istep = 1 do ilo = ihi ihi = ilo + istep if ( ihi >= n ) then if ( x >= xt ( n ) ) then mflag = 1 ileft = n - 1 iright = n if ( present ( inearest )) inearest = n return end if ihi = n elseif ( x >= xt ( ihi ) ) then istep = istep * 2 cycle endif exit end do else if ( x >= xt ( ilo ) ) then mflag = 0 ileft = ilo iright = ilo + 1 if ( present ( inearest )) then if ( abs ( x - xt ( ileft )) <= abs ( x - xt ( iright )) ) then inearest = ileft else inearest = iright end if end if return end if ! now x <= xt(ihi). find lower bound istep = 1 do ihi = ilo ilo = ihi - istep if ( ilo <= 1 ) then ilo = 1 if ( x < xt ( 1 ) ) then mflag = - 1 ileft = 1 iright = 2 if ( present ( inearest )) inearest = 1 return end if elseif ( x < xt ( ilo ) ) then istep = istep * 2 cycle endif exit end do endif ! now xt(ilo) <= x < xt(ihi). narrow the interval do imid = ( ilo + ihi ) / 2 if ( imid == ilo ) then mflag = 0 ileft = ilo iright = ilo + 1 if ( present ( inearest )) then if ( abs ( x - xt ( ileft )) <= abs ( x - xt ( iright )) ) then inearest = ileft else inearest = iright end if end if return end if ! note. it is assumed that imid = ilo in case ihi = ilo+1 if ( x < xt ( imid ) ) then ihi = imid else ilo = imid endif end do end subroutine dintrv !***************************************************************************************** !***************************************************************************************** !> !  1D nearest neighbor interpolation routine. pure subroutine nearest_1d ( me , x , f , istat ) implicit none class ( nearest_interp_1d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( out ) :: f !! Nearest  f(x)  integer , intent ( out ), optional :: istat !! `0`  : no problems, !! `-1` : class has not been initialized integer :: mflag integer , dimension ( 2 ) :: ix integer :: i if ( me % initialized ) then call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag , i ) f = me % f ( i ) if ( present ( istat )) istat = 0 else if ( present ( istat )) istat = - 1 f = zero end if end subroutine nearest_1d !***************************************************************************************** !***************************************************************************************** !> !  2D nearest neighbor interpolation routine. pure subroutine nearest_2d ( me , x , y , f , istat ) implicit none class ( nearest_interp_2d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( out ) :: f !! Nearest  f(x,y)  integer , intent ( out ), optional :: istat !! `0`  : no problems, !! `-1` : class has not been initialized integer :: mflag integer , dimension ( 2 ) :: ix , iy integer :: i , j if ( me % initialized ) then call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag , i ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag , j ) f = me % f ( i , j ) if ( present ( istat )) istat = 0 else if ( present ( istat )) istat = - 1 f = zero end if end subroutine nearest_2d !***************************************************************************************** !***************************************************************************************** !> !  3D nearest neighbor interpolation routine. pure subroutine nearest_3d ( me , x , y , z , f , istat ) implicit none class ( nearest_interp_3d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( out ) :: f !! Nearest  f(x,y,z)  integer , intent ( out ), optional :: istat !! `0`  : no problems, !! `-1` : class has not been initialized integer :: mflag integer , dimension ( 2 ) :: ix , iy , iz integer :: i , j , k if ( me % initialized ) then call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag , i ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag , j ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag , k ) f = me % f ( i , j , k ) if ( present ( istat )) istat = 0 else if ( present ( istat )) istat = - 1 f = zero end if end subroutine nearest_3d !***************************************************************************************** !***************************************************************************************** !> !  4D nearest neighbor interpolation routine. pure subroutine nearest_4d ( me , x , y , z , q , f , istat ) implicit none class ( nearest_interp_4d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( in ) :: q real ( wp ), intent ( out ) :: f !! Nearest  f(x,y,z,q)  integer , intent ( out ), optional :: istat !! `0`  : no problems, !! `-1` : class has not been initialized integer :: mflag integer , dimension ( 2 ) :: ix , iy , iz , iq integer :: i , j , k , l if ( me % initialized ) then call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag , i ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag , j ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag , k ) call dintrv ( me % q , q , me % iloq , iq ( 1 ), iq ( 2 ), mflag , l ) f = me % f ( i , j , k , l ) if ( present ( istat )) istat = 0 else if ( present ( istat )) istat = - 1 f = zero end if end subroutine nearest_4d !***************************************************************************************** !***************************************************************************************** !> !  5D nearest neighbor interpolation routine. pure subroutine nearest_5d ( me , x , y , z , q , r , f , istat ) implicit none class ( nearest_interp_5d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( in ) :: q real ( wp ), intent ( in ) :: r real ( wp ), intent ( out ) :: f !! Nearest  f(x,y,z,q,r)  integer , intent ( out ), optional :: istat !! `0`  : no problems, !! `-1` : class has not been initialized integer :: mflag integer , dimension ( 2 ) :: ix , iy , iz , iq , ir integer :: i , j , k , l , m if ( me % initialized ) then call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag , i ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag , j ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag , k ) call dintrv ( me % q , q , me % iloq , iq ( 1 ), iq ( 2 ), mflag , l ) call dintrv ( me % r , r , me % ilor , ir ( 1 ), ir ( 2 ), mflag , m ) f = me % f ( i , j , k , l , m ) if ( present ( istat )) istat = 0 else if ( present ( istat )) istat = - 1 f = zero end if end subroutine nearest_5d !***************************************************************************************** !***************************************************************************************** !> !  6D nearest neighbor interpolation routine. pure subroutine nearest_6d ( me , x , y , z , q , r , s , f , istat ) implicit none class ( nearest_interp_6d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( in ) :: q real ( wp ), intent ( in ) :: r real ( wp ), intent ( in ) :: s real ( wp ), intent ( out ) :: f !! Nearest  f(x,y,z,q,r,s)  integer , intent ( out ), optional :: istat !! `0`  : no problems, !! `-1` : class has not been initialized integer :: mflag integer , dimension ( 2 ) :: ix , iy , iz , iq , ir , is integer :: i , j , k , l , m , n if ( me % initialized ) then call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag , i ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag , j ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag , k ) call dintrv ( me % q , q , me % iloq , iq ( 1 ), iq ( 2 ), mflag , l ) call dintrv ( me % r , r , me % ilor , ir ( 1 ), ir ( 2 ), mflag , m ) call dintrv ( me % s , s , me % ilos , is ( 1 ), is ( 2 ), mflag , n ) f = me % f ( i , j , k , l , m , n ) if ( present ( istat )) istat = 0 else if ( present ( istat )) istat = - 1 f = zero end if end subroutine nearest_6d !***************************************************************************************** !***************************************************************************************** !> !  Check the validity of the inputs to the initialize routines. !  Prints warning message if there is an error, !  and also sets `ierr` (/=0 if there were any errors). ! !  Supports up to 6D: x,y,z,q,r,s ! !# History !  * Jacob Williams, 2/24/2015 : Created this routine. !  * Jacob Williams, 2/23/2016 : modified for linear interp module. pure subroutine check_inputs ( me , x , y , z , q , r , s , ierr ) implicit none class ( linear_interp_class ), intent ( in ) :: me real ( wp ), dimension (:), intent ( in ), optional :: x !! `x` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: y !! `y` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: z !! `z` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: q !! `q` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: r !! `r` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: s !! `s` abscissa vector integer , intent ( out ) :: ierr !! `0`   : no problems, !! `1`   : `x` is not strictly increasing, !! `2`   : `y` is not strictly increasing, !! `3`   : `z` is not strictly increasing, !! `4`   : `q` is not strictly increasing, !! `5`   : `r` is not strictly increasing, !! `6`   : `s` is not strictly increasing, !! `100` : cannot use linear interpolation for only one point. ierr = 0 ! initialize if ( present ( x )) call check ( x , 1 , ierr ); if ( ierr /= 0 ) return if ( present ( y )) call check ( y , 2 , ierr ); if ( ierr /= 0 ) return if ( present ( z )) call check ( z , 3 , ierr ); if ( ierr /= 0 ) return if ( present ( q )) call check ( q , 4 , ierr ); if ( ierr /= 0 ) return if ( present ( r )) call check ( r , 5 , ierr ); if ( ierr /= 0 ) return if ( present ( s )) call check ( s , 6 , ierr ); if ( ierr /= 0 ) return if ( ierr == 0 ) then select type ( me ) class is ( nearest_interp_1d ) class is ( nearest_interp_2d ) class is ( nearest_interp_3d ) class is ( nearest_interp_4d ) class is ( nearest_interp_5d ) class is ( nearest_interp_6d ) class default ! need at least two points for linear interpolation: if ( size ( x ) == 1 ) ierr = 100 end select end if contains !***************************************************************************************** pure subroutine check ( v , error_code , ierr ) implicit none real ( wp ), dimension (:), intent ( in ) :: v !! abcissae vector integer , intent ( in ) :: error_code !! error code for check integer , intent ( inout ) :: ierr !! will be set to `error_code` if there is a problem integer :: i !! counter integer :: n !! size of the input `v` array n = size ( v ) do i = 2 , n if ( v ( i ) <= v ( i - 1 )) then ierr = error_code exit end if end do end subroutine check end subroutine check_inputs !***************************************************************************************** !***************************************************************************************** end module linear_interpolation_module !*****************************************************************************************","tags":"","loc":"sourcefile/linear_interpolation_module.f90.html"},{"title":"linear_interp_class â€“ finterp ","text":"type, private, abstract :: linear_interp_class Base class for the linear interpolation types Inherited by type~~linear_interp_class~~InheritedByGraph type~linear_interp_class linear_interp_class type~linear_interp_2d linear_interp_2d type~linear_interp_2d->type~linear_interp_class type~linear_interp_1d linear_interp_1d type~linear_interp_1d->type~linear_interp_class type~linear_interp_5d linear_interp_5d type~linear_interp_5d->type~linear_interp_class type~linear_interp_3d linear_interp_3d type~linear_interp_3d->type~linear_interp_class type~linear_interp_4d linear_interp_4d type~linear_interp_4d->type~linear_interp_class type~linear_interp_6d linear_interp_6d type~linear_interp_6d->type~linear_interp_class type~nearest_interp_4d nearest_interp_4d type~nearest_interp_4d->type~linear_interp_4d type~nearest_interp_3d nearest_interp_3d type~nearest_interp_3d->type~linear_interp_3d type~nearest_interp_1d nearest_interp_1d type~nearest_interp_1d->type~linear_interp_1d type~nearest_interp_5d nearest_interp_5d type~nearest_interp_5d->type~linear_interp_5d type~nearest_interp_6d nearest_interp_6d type~nearest_interp_6d->type~linear_interp_6d type~nearest_interp_2d nearest_interp_2d type~nearest_interp_2d->type~linear_interp_2d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables initialized Type-Bound Procedures destroy check_inputs Components Type Visibility Attributes Name Initial logical, private :: initialized = .false. if the class was properly initialized Type-Bound Procedures procedure( destroy_func ), public, deferred :: destroy destructor pure elemental subroutine destroy_func(me) Prototype interface for bspline destructor routines Arguments Type Intent Optional Attributes Name class( linear_interp_class ), intent(inout) :: me procedure, private :: check_inputs private pure subroutine check_inputs (me, x, y, z, q, r, s, ierr) Check the validity of the inputs to the initialize routines.\n  Prints warning message if there is an error,\n  and also sets ierr (/=0 if there were any errors). Read moreâ€¦ Arguments Type Intent Optional Attributes Name class( linear_interp_class ), intent(in) :: me real(kind=wp), intent(in), optional dimension(:) :: x x abscissa vector real(kind=wp), intent(in), optional dimension(:) :: y y abscissa vector real(kind=wp), intent(in), optional dimension(:) :: z z abscissa vector real(kind=wp), intent(in), optional dimension(:) :: q q abscissa vector real(kind=wp), intent(in), optional dimension(:) :: r r abscissa vector real(kind=wp), intent(in), optional dimension(:) :: s s abscissa vector integer, intent(out) :: ierr 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 6 : s is not strictly increasing, 100 : cannot use linear interpolation for only one point.","tags":"","loc":"type/linear_interp_class.html"},{"title":"linear_interp_1d â€“ finterp ","text":"type, private, extends( linear_interp_class ) :: linear_interp_1d Class for 1d linear interpolation. Inherits type~~linear_interp_1d~~InheritsGraph type~linear_interp_1d linear_interp_1d type~linear_interp_class linear_interp_class type~linear_interp_1d->type~linear_interp_class Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~linear_interp_1d~~InheritedByGraph type~linear_interp_1d linear_interp_1d type~nearest_interp_1d nearest_interp_1d type~nearest_interp_1d->type~linear_interp_1d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables f x ilox Finalization Procedures finalize_1d Type-Bound Procedures initialize evaluate destroy Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x integer, private :: ilox = 1 Finalization Procedures final :: finalize_1d private pure elemental subroutine finalize_1d (me) Finalizer for a linear_interp_1d type. Arguments Type Intent Optional Attributes Name type( linear_interp_1d ), intent(inout) :: me Type-Bound Procedures procedure, public :: initialize => initialize_1d private pure subroutine initialize_1d (me, x, f, istat) Constructor for a linear_interp_1d class. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 10 : x is not equal to size(f,1), 100 : cannot use linear interpolation for only one point. procedure, public :: evaluate => interp_1d private pure subroutine interp_1d (me, x, f, istat) 1D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized procedure, public :: destroy => destroy_1d private pure elemental subroutine destroy_1d (me) Destructor for a linear_interp_1d class. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me","tags":"","loc":"type/linear_interp_1d.html"},{"title":"linear_interp_2d â€“ finterp ","text":"type, private, extends( linear_interp_class ) :: linear_interp_2d Class for 2d linear interpolation. Inherits type~~linear_interp_2d~~InheritsGraph type~linear_interp_2d linear_interp_2d type~linear_interp_class linear_interp_class type~linear_interp_2d->type~linear_interp_class Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~linear_interp_2d~~InheritedByGraph type~linear_interp_2d linear_interp_2d type~nearest_interp_2d nearest_interp_2d type~nearest_interp_2d->type~linear_interp_2d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables f x y ilox iloy Finalization Procedures finalize_2d Type-Bound Procedures initialize evaluate destroy Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y integer, private :: ilox = 1 integer, private :: iloy = 1 Finalization Procedures final :: finalize_2d private pure elemental subroutine finalize_2d (me) Finalizer for a linear_interp_2d type. Arguments Type Intent Optional Attributes Name type( linear_interp_2d ), intent(inout) :: me Type-Bound Procedures procedure, public :: initialize => initialize_2d private pure subroutine initialize_2d (me, x, y, f, istat) Constructor for a linear_interp_2d class. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 100 : cannot use linear interpolation for only one point. procedure, public :: evaluate => interp_2d private pure subroutine interp_2d (me, x, y, f, istat) 2D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized procedure, public :: destroy => destroy_2d private pure elemental subroutine destroy_2d (me) Destructor for a linear_interp_2d class. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me","tags":"","loc":"type/linear_interp_2d.html"},{"title":"linear_interp_3d â€“ finterp ","text":"type, private, extends( linear_interp_class ) :: linear_interp_3d Class for 3d linear interpolation. Inherits type~~linear_interp_3d~~InheritsGraph type~linear_interp_3d linear_interp_3d type~linear_interp_class linear_interp_class type~linear_interp_3d->type~linear_interp_class Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~linear_interp_3d~~InheritedByGraph type~linear_interp_3d linear_interp_3d type~nearest_interp_3d nearest_interp_3d type~nearest_interp_3d->type~linear_interp_3d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables f x y z ilox iloy iloz Finalization Procedures finalize_3d Type-Bound Procedures initialize evaluate destroy Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y real(kind=wp), private, dimension(:), allocatable :: z integer, private :: ilox = 1 integer, private :: iloy = 1 integer, private :: iloz = 1 Finalization Procedures final :: finalize_3d private pure elemental subroutine finalize_3d (me) Finalizer for a linear_interp_3d type. Arguments Type Intent Optional Attributes Name type( linear_interp_3d ), intent(inout) :: me Type-Bound Procedures procedure, public :: initialize => initialize_3d private pure subroutine initialize_3d (me, x, y, z, f, istat) Constructor for a linear_interp_3d class. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 100 : cannot use linear interpolation for only one point. procedure, public :: evaluate => interp_3d private pure subroutine interp_3d (me, x, y, z, f, istat) 3D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized procedure, public :: destroy => destroy_3d private pure elemental subroutine destroy_3d (me) Destructor for a linear_interp_3d class. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me","tags":"","loc":"type/linear_interp_3d.html"},{"title":"linear_interp_4d â€“ finterp ","text":"type, private, extends( linear_interp_class ) :: linear_interp_4d Class for 4d linear interpolation. Inherits type~~linear_interp_4d~~InheritsGraph type~linear_interp_4d linear_interp_4d type~linear_interp_class linear_interp_class type~linear_interp_4d->type~linear_interp_class Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~linear_interp_4d~~InheritedByGraph type~linear_interp_4d linear_interp_4d type~nearest_interp_4d nearest_interp_4d type~nearest_interp_4d->type~linear_interp_4d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables f x y z q ilox iloy iloz iloq Finalization Procedures finalize_4d Type-Bound Procedures initialize evaluate destroy Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y real(kind=wp), private, dimension(:), allocatable :: z real(kind=wp), private, dimension(:), allocatable :: q integer, private :: ilox = 1 integer, private :: iloy = 1 integer, private :: iloz = 1 integer, private :: iloq = 1 Finalization Procedures final :: finalize_4d private pure elemental subroutine finalize_4d (me) Finalizer for a linear_interp_4d type. Arguments Type Intent Optional Attributes Name type( linear_interp_4d ), intent(inout) :: me Type-Bound Procedures procedure, public :: initialize => initialize_4d private pure subroutine initialize_4d (me, x, y, z, q, f, istat) Constructor for a linear_interp_4d class. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 100 : cannot use linear interpolation for only one point. procedure, public :: evaluate => interp_4d private pure subroutine interp_4d (me, x, y, z, q, f, istat) 4D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized procedure, public :: destroy => destroy_4d private pure elemental subroutine destroy_4d (me) Destructor for a linear_interp_4d class. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me","tags":"","loc":"type/linear_interp_4d.html"},{"title":"linear_interp_5d â€“ finterp ","text":"type, private, extends( linear_interp_class ) :: linear_interp_5d Class for 5d linear interpolation. Inherits type~~linear_interp_5d~~InheritsGraph type~linear_interp_5d linear_interp_5d type~linear_interp_class linear_interp_class type~linear_interp_5d->type~linear_interp_class Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~linear_interp_5d~~InheritedByGraph type~linear_interp_5d linear_interp_5d type~nearest_interp_5d nearest_interp_5d type~nearest_interp_5d->type~linear_interp_5d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables f x y z q r ilox iloy iloz iloq ilor Finalization Procedures finalize_5d Type-Bound Procedures initialize evaluate destroy Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:,:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y real(kind=wp), private, dimension(:), allocatable :: z real(kind=wp), private, dimension(:), allocatable :: q real(kind=wp), private, dimension(:), allocatable :: r integer, private :: ilox = 1 integer, private :: iloy = 1 integer, private :: iloz = 1 integer, private :: iloq = 1 integer, private :: ilor = 1 Finalization Procedures final :: finalize_5d private pure elemental subroutine finalize_5d (me) Finalizer for a linear_interp_5d type. Arguments Type Intent Optional Attributes Name type( linear_interp_5d ), intent(inout) :: me Type-Bound Procedures procedure, public :: initialize => initialize_5d private pure subroutine initialize_5d (me, x, y, z, q, r, f, istat) Constructor for a linear_interp_5d class. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 50 : r is not equal to size(f,5), 100 : cannot use linear interpolation for only one point. procedure, public :: evaluate => interp_5d private pure subroutine interp_5d (me, x, y, z, q, r, f, istat) 5D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized procedure, public :: destroy => destroy_5d private pure elemental subroutine destroy_5d (me) Destructor for a linear_interp_5d class. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me","tags":"","loc":"type/linear_interp_5d.html"},{"title":"linear_interp_6d â€“ finterp ","text":"type, private, extends( linear_interp_class ) :: linear_interp_6d Class for 6d linear interpolation. Inherits type~~linear_interp_6d~~InheritsGraph type~linear_interp_6d linear_interp_6d type~linear_interp_class linear_interp_class type~linear_interp_6d->type~linear_interp_class Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~linear_interp_6d~~InheritedByGraph type~linear_interp_6d linear_interp_6d type~nearest_interp_6d nearest_interp_6d type~nearest_interp_6d->type~linear_interp_6d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables f x y z q r s ilox iloy iloz iloq ilor ilos Finalization Procedures finalize_6d Type-Bound Procedures initialize evaluate destroy Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:,:,:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y real(kind=wp), private, dimension(:), allocatable :: z real(kind=wp), private, dimension(:), allocatable :: q real(kind=wp), private, dimension(:), allocatable :: r real(kind=wp), private, dimension(:), allocatable :: s integer, private :: ilox = 1 integer, private :: iloy = 1 integer, private :: iloz = 1 integer, private :: iloq = 1 integer, private :: ilor = 1 integer, private :: ilos = 1 Finalization Procedures final :: finalize_6d private pure elemental subroutine finalize_6d (me) Finalizer for a linear_interp_6d type. Arguments Type Intent Optional Attributes Name type( linear_interp_6d ), intent(inout) :: me Type-Bound Procedures procedure, public :: initialize => initialize_6d private pure subroutine initialize_6d (me, x, y, z, q, r, s, f, istat) Constructor for a linear_interp_6d class. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 6 : s is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 50 : r is not equal to size(f,5), 60 : s is not equal to size(f,6), 100 : cannot use linear interpolation for only one point. procedure, public :: evaluate => interp_6d private pure subroutine interp_6d (me, x, y, z, q, r, s, f, istat) 6D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(in) :: s real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized procedure, public :: destroy => destroy_6d private pure elemental subroutine destroy_6d (me) Destructor for a linear_interp_6d class. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me","tags":"","loc":"type/linear_interp_6d.html"},{"title":"nearest_interp_1d â€“ finterp ","text":"type, public, extends( linear_interp_1d ) :: nearest_interp_1d Class for 1d nearest neighbor interpolation. Inherits type~~nearest_interp_1d~~InheritsGraph type~nearest_interp_1d nearest_interp_1d type~linear_interp_1d linear_interp_1d type~nearest_interp_1d->type~linear_interp_1d type~linear_interp_class linear_interp_class type~linear_interp_1d->type~linear_interp_class Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures initialize destroy evaluate Type-Bound Procedures procedure, public :: initialize => initialize_1d private pure subroutine initialize_1d (me, x, f, istat) Constructor for a linear_interp_1d class. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 10 : x is not equal to size(f,1), 100 : cannot use linear interpolation for only one point. procedure, public :: destroy => destroy_1d private pure elemental subroutine destroy_1d (me) Destructor for a linear_interp_1d class. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me procedure, public :: evaluate => nearest_1d private pure subroutine nearest_1d (me, x, f, istat) 1D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_1d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized","tags":"","loc":"type/nearest_interp_1d.html"},{"title":"nearest_interp_2d â€“ finterp ","text":"type, public, extends( linear_interp_2d ) :: nearest_interp_2d Class for 2d nearest neighbor interpolation. Inherits type~~nearest_interp_2d~~InheritsGraph type~nearest_interp_2d nearest_interp_2d type~linear_interp_2d linear_interp_2d type~nearest_interp_2d->type~linear_interp_2d type~linear_interp_class linear_interp_class type~linear_interp_2d->type~linear_interp_class Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures initialize destroy evaluate Type-Bound Procedures procedure, public :: initialize => initialize_2d private pure subroutine initialize_2d (me, x, y, f, istat) Constructor for a linear_interp_2d class. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 100 : cannot use linear interpolation for only one point. procedure, public :: destroy => destroy_2d private pure elemental subroutine destroy_2d (me) Destructor for a linear_interp_2d class. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me procedure, public :: evaluate => nearest_2d private pure subroutine nearest_2d (me, x, y, f, istat) 2D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_2d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized","tags":"","loc":"type/nearest_interp_2d.html"},{"title":"nearest_interp_3d â€“ finterp ","text":"type, public, extends( linear_interp_3d ) :: nearest_interp_3d Class for 3d nearest neighbor interpolation. Inherits type~~nearest_interp_3d~~InheritsGraph type~nearest_interp_3d nearest_interp_3d type~linear_interp_3d linear_interp_3d type~nearest_interp_3d->type~linear_interp_3d type~linear_interp_class linear_interp_class type~linear_interp_3d->type~linear_interp_class Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures initialize destroy evaluate Type-Bound Procedures procedure, public :: initialize => initialize_3d private pure subroutine initialize_3d (me, x, y, z, f, istat) Constructor for a linear_interp_3d class. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 100 : cannot use linear interpolation for only one point. procedure, public :: destroy => destroy_3d private pure elemental subroutine destroy_3d (me) Destructor for a linear_interp_3d class. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me procedure, public :: evaluate => nearest_3d private pure subroutine nearest_3d (me, x, y, z, f, istat) 3D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_3d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized","tags":"","loc":"type/nearest_interp_3d.html"},{"title":"nearest_interp_4d â€“ finterp ","text":"type, public, extends( linear_interp_4d ) :: nearest_interp_4d Class for 4d nearest neighbor interpolation. Inherits type~~nearest_interp_4d~~InheritsGraph type~nearest_interp_4d nearest_interp_4d type~linear_interp_4d linear_interp_4d type~nearest_interp_4d->type~linear_interp_4d type~linear_interp_class linear_interp_class type~linear_interp_4d->type~linear_interp_class Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures initialize destroy evaluate Type-Bound Procedures procedure, public :: initialize => initialize_4d private pure subroutine initialize_4d (me, x, y, z, q, f, istat) Constructor for a linear_interp_4d class. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 100 : cannot use linear interpolation for only one point. procedure, public :: destroy => destroy_4d private pure elemental subroutine destroy_4d (me) Destructor for a linear_interp_4d class. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me procedure, public :: evaluate => nearest_4d private pure subroutine nearest_4d (me, x, y, z, q, f, istat) 4D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_4d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized","tags":"","loc":"type/nearest_interp_4d.html"},{"title":"nearest_interp_5d â€“ finterp ","text":"type, public, extends( linear_interp_5d ) :: nearest_interp_5d Class for 5d nearest neighbor interpolation. Inherits type~~nearest_interp_5d~~InheritsGraph type~nearest_interp_5d nearest_interp_5d type~linear_interp_5d linear_interp_5d type~nearest_interp_5d->type~linear_interp_5d type~linear_interp_class linear_interp_class type~linear_interp_5d->type~linear_interp_class Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures initialize destroy evaluate Type-Bound Procedures procedure, public :: initialize => initialize_5d private pure subroutine initialize_5d (me, x, y, z, q, r, f, istat) Constructor for a linear_interp_5d class. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 50 : r is not equal to size(f,5), 100 : cannot use linear interpolation for only one point. procedure, public :: destroy => destroy_5d private pure elemental subroutine destroy_5d (me) Destructor for a linear_interp_5d class. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me procedure, public :: evaluate => nearest_5d private pure subroutine nearest_5d (me, x, y, z, q, r, f, istat) 5D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_5d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized","tags":"","loc":"type/nearest_interp_5d.html"},{"title":"nearest_interp_6d â€“ finterp ","text":"type, public, extends( linear_interp_6d ) :: nearest_interp_6d Class for 6d nearest neighbor interpolation. Inherits type~~nearest_interp_6d~~InheritsGraph type~nearest_interp_6d nearest_interp_6d type~linear_interp_6d linear_interp_6d type~nearest_interp_6d->type~linear_interp_6d type~linear_interp_class linear_interp_class type~linear_interp_6d->type~linear_interp_class Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures initialize destroy evaluate Type-Bound Procedures procedure, public :: initialize => initialize_6d private pure subroutine initialize_6d (me, x, y, z, q, r, s, f, istat) Constructor for a linear_interp_6d class. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 6 : s is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 50 : r is not equal to size(f,5), 60 : s is not equal to size(f,6), 100 : cannot use linear interpolation for only one point. procedure, public :: destroy => destroy_6d private pure elemental subroutine destroy_6d (me) Destructor for a linear_interp_6d class. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me procedure, public :: evaluate => nearest_6d private pure subroutine nearest_6d (me, x, y, z, q, r, s, f, istat) 6D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_6d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(in) :: s real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized","tags":"","loc":"type/nearest_interp_6d.html"},{"title":"destroy_func â€“ finterp","text":"abstract interface private pure elemental subroutine destroy_func(me) Arguments Type Intent Optional Attributes Name class( linear_interp_class ), intent(inout) :: me Description interface for bspline destructor routines","tags":"","loc":"interface/destroy_func.html"},{"title":"finalize_1d â€“ finterp","text":"private pure elemental subroutine finalize_1d(me) Finalizer for a linear_interp_1d type. Arguments Type Intent Optional Attributes Name type( linear_interp_1d ), intent(inout) :: me Contents None","tags":"","loc":"proc/finalize_1d.html"},{"title":"finalize_2d â€“ finterp","text":"private pure elemental subroutine finalize_2d(me) Finalizer for a linear_interp_2d type. Arguments Type Intent Optional Attributes Name type( linear_interp_2d ), intent(inout) :: me Contents None","tags":"","loc":"proc/finalize_2d.html"},{"title":"finalize_3d â€“ finterp","text":"private pure elemental subroutine finalize_3d(me) Finalizer for a linear_interp_3d type. Arguments Type Intent Optional Attributes Name type( linear_interp_3d ), intent(inout) :: me Contents None","tags":"","loc":"proc/finalize_3d.html"},{"title":"finalize_4d â€“ finterp","text":"private pure elemental subroutine finalize_4d(me) Finalizer for a linear_interp_4d type. Arguments Type Intent Optional Attributes Name type( linear_interp_4d ), intent(inout) :: me Contents None","tags":"","loc":"proc/finalize_4d.html"},{"title":"finalize_5d â€“ finterp","text":"private pure elemental subroutine finalize_5d(me) Finalizer for a linear_interp_5d type. Arguments Type Intent Optional Attributes Name type( linear_interp_5d ), intent(inout) :: me Contents None","tags":"","loc":"proc/finalize_5d.html"},{"title":"finalize_6d â€“ finterp","text":"private pure elemental subroutine finalize_6d(me) Finalizer for a linear_interp_6d type. Arguments Type Intent Optional Attributes Name type( linear_interp_6d ), intent(inout) :: me Contents None","tags":"","loc":"proc/finalize_6d.html"},{"title":"destroy_1d â€“ finterp","text":"private pure elemental subroutine destroy_1d(me) Destructor for a linear_interp_1d class. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me Contents None","tags":"","loc":"proc/destroy_1d.html"},{"title":"destroy_2d â€“ finterp","text":"private pure elemental subroutine destroy_2d(me) Destructor for a linear_interp_2d class. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me Contents None","tags":"","loc":"proc/destroy_2d.html"},{"title":"destroy_3d â€“ finterp","text":"private pure elemental subroutine destroy_3d(me) Destructor for a linear_interp_3d class. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me Contents None","tags":"","loc":"proc/destroy_3d.html"},{"title":"destroy_4d â€“ finterp","text":"private pure elemental subroutine destroy_4d(me) Destructor for a linear_interp_4d class. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me Contents None","tags":"","loc":"proc/destroy_4d.html"},{"title":"destroy_5d â€“ finterp","text":"private pure elemental subroutine destroy_5d(me) Destructor for a linear_interp_5d class. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me Contents None","tags":"","loc":"proc/destroy_5d.html"},{"title":"destroy_6d â€“ finterp","text":"private pure elemental subroutine destroy_6d(me) Destructor for a linear_interp_6d class. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me Contents None","tags":"","loc":"proc/destroy_6d.html"},{"title":"initialize_1d â€“ finterp","text":"private pure subroutine initialize_1d(me, x, f, istat) Constructor for a linear_interp_1d class. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 10 : x is not equal to size(f,1), 100 : cannot use linear interpolation for only one point. Contents None","tags":"","loc":"proc/initialize_1d.html"},{"title":"initialize_2d â€“ finterp","text":"private pure subroutine initialize_2d(me, x, y, f, istat) Constructor for a linear_interp_2d class. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 100 : cannot use linear interpolation for only one point. Contents None","tags":"","loc":"proc/initialize_2d.html"},{"title":"initialize_3d â€“ finterp","text":"private pure subroutine initialize_3d(me, x, y, z, f, istat) Constructor for a linear_interp_3d class. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 100 : cannot use linear interpolation for only one point. Contents None","tags":"","loc":"proc/initialize_3d.html"},{"title":"initialize_4d â€“ finterp","text":"private pure subroutine initialize_4d(me, x, y, z, q, f, istat) Constructor for a linear_interp_4d class. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 100 : cannot use linear interpolation for only one point. Contents None","tags":"","loc":"proc/initialize_4d.html"},{"title":"initialize_5d â€“ finterp","text":"private pure subroutine initialize_5d(me, x, y, z, q, r, f, istat) Constructor for a linear_interp_5d class. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 50 : r is not equal to size(f,5), 100 : cannot use linear interpolation for only one point. Contents None","tags":"","loc":"proc/initialize_5d.html"},{"title":"initialize_6d â€“ finterp","text":"private pure subroutine initialize_6d(me, x, y, z, q, r, s, f, istat) Constructor for a linear_interp_6d class. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 6 : s is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 50 : r is not equal to size(f,5), 60 : s is not equal to size(f,6), 100 : cannot use linear interpolation for only one point. Contents None","tags":"","loc":"proc/initialize_6d.html"},{"title":"interp_1d â€“ finterp","text":"private pure subroutine interp_1d(me, x, f, istat) 1D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized Calls proc~~interp_1d~~CallsGraph proc~interp_1d interp_1d proc~dintrv dintrv proc~interp_1d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ix p1 q1 mflag Variables Type Visibility Attributes Name Initial integer, private, dimension(2) :: ix real(kind=wp), private :: p1 real(kind=wp), private :: q1 integer, private :: mflag","tags":"","loc":"proc/interp_1d.html"},{"title":"interp_2d â€“ finterp","text":"private pure subroutine interp_2d(me, x, y, f, istat) 2D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized Calls proc~~interp_2d~~CallsGraph proc~interp_2d interp_2d proc~dintrv dintrv proc~interp_2d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ix iy p1 p2 q1 q2 mflag fx1 fx2 Variables Type Visibility Attributes Name Initial integer, private, dimension(2) :: ix integer, private, dimension(2) :: iy real(kind=wp), private :: p1 real(kind=wp), private :: p2 real(kind=wp), private :: q1 real(kind=wp), private :: q2 integer, private :: mflag real(kind=wp), private :: fx1 real(kind=wp), private :: fx2","tags":"","loc":"proc/interp_2d.html"},{"title":"interp_3d â€“ finterp","text":"private pure subroutine interp_3d(me, x, y, z, f, istat) 3D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized Calls proc~~interp_3d~~CallsGraph proc~interp_3d interp_3d proc~dintrv dintrv proc~interp_3d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ix iy iz p1 p2 p3 q1 q2 q3 mflag fx11 fx21 fx12 fx22 fxy1 fxy2 Variables Type Visibility Attributes Name Initial integer, private, dimension(2) :: ix integer, private, dimension(2) :: iy integer, private, dimension(2) :: iz real(kind=wp), private :: p1 real(kind=wp), private :: p2 real(kind=wp), private :: p3 real(kind=wp), private :: q1 real(kind=wp), private :: q2 real(kind=wp), private :: q3 integer, private :: mflag real(kind=wp), private :: fx11 real(kind=wp), private :: fx21 real(kind=wp), private :: fx12 real(kind=wp), private :: fx22 real(kind=wp), private :: fxy1 real(kind=wp), private :: fxy2","tags":"","loc":"proc/interp_3d.html"},{"title":"interp_4d â€“ finterp","text":"private pure subroutine interp_4d(me, x, y, z, q, f, istat) 4D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized Calls proc~~interp_4d~~CallsGraph proc~interp_4d interp_4d proc~dintrv dintrv proc~interp_4d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ix iy iz iq p1 p2 p3 p4 q1 q2 q3 q4 mflag fx111 fx211 fx121 fx221 fxy11 fxy21 fxyz1 fx112 fx212 fx122 fx222 fxy12 fxy22 fxyz2 Variables Type Visibility Attributes Name Initial integer, private, dimension(2) :: ix integer, private, dimension(2) :: iy integer, private, dimension(2) :: iz integer, private, dimension(2) :: iq real(kind=wp), private :: p1 real(kind=wp), private :: p2 real(kind=wp), private :: p3 real(kind=wp), private :: p4 real(kind=wp), private :: q1 real(kind=wp), private :: q2 real(kind=wp), private :: q3 real(kind=wp), private :: q4 integer, private :: mflag real(kind=wp), private :: fx111 real(kind=wp), private :: fx211 real(kind=wp), private :: fx121 real(kind=wp), private :: fx221 real(kind=wp), private :: fxy11 real(kind=wp), private :: fxy21 real(kind=wp), private :: fxyz1 real(kind=wp), private :: fx112 real(kind=wp), private :: fx212 real(kind=wp), private :: fx122 real(kind=wp), private :: fx222 real(kind=wp), private :: fxy12 real(kind=wp), private :: fxy22 real(kind=wp), private :: fxyz2","tags":"","loc":"proc/interp_4d.html"},{"title":"interp_5d â€“ finterp","text":"private pure subroutine interp_5d(me, x, y, z, q, r, f, istat) 5D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized Calls proc~~interp_5d~~CallsGraph proc~interp_5d interp_5d proc~dintrv dintrv proc~interp_5d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ix iy iz iq ir p1 p2 p3 p4 p5 q1 q2 q3 q4 q5 mflag fx1111 fx2111 fx1211 fx2211 fx1121 fx2121 fx1221 fx2221 fxy111 fxy211 fxy121 fxy221 fxyz11 fxyz21 fxyzq1 fx1112 fx2112 fx1212 fx2212 fx1122 fx2122 fx1222 fx2222 fxy112 fxy212 fxy122 fxy222 fxyz12 fxyz22 fxyzq2 Variables Type Visibility Attributes Name Initial integer, private, dimension(2) :: ix integer, private, dimension(2) :: iy integer, private, dimension(2) :: iz integer, private, dimension(2) :: iq integer, private, dimension(2) :: ir real(kind=wp), private :: p1 real(kind=wp), private :: p2 real(kind=wp), private :: p3 real(kind=wp), private :: p4 real(kind=wp), private :: p5 real(kind=wp), private :: q1 real(kind=wp), private :: q2 real(kind=wp), private :: q3 real(kind=wp), private :: q4 real(kind=wp), private :: q5 integer, private :: mflag real(kind=wp), private :: fx1111 real(kind=wp), private :: fx2111 real(kind=wp), private :: fx1211 real(kind=wp), private :: fx2211 real(kind=wp), private :: fx1121 real(kind=wp), private :: fx2121 real(kind=wp), private :: fx1221 real(kind=wp), private :: fx2221 real(kind=wp), private :: fxy111 real(kind=wp), private :: fxy211 real(kind=wp), private :: fxy121 real(kind=wp), private :: fxy221 real(kind=wp), private :: fxyz11 real(kind=wp), private :: fxyz21 real(kind=wp), private :: fxyzq1 real(kind=wp), private :: fx1112 real(kind=wp), private :: fx2112 real(kind=wp), private :: fx1212 real(kind=wp), private :: fx2212 real(kind=wp), private :: fx1122 real(kind=wp), private :: fx2122 real(kind=wp), private :: fx1222 real(kind=wp), private :: fx2222 real(kind=wp), private :: fxy112 real(kind=wp), private :: fxy212 real(kind=wp), private :: fxy122 real(kind=wp), private :: fxy222 real(kind=wp), private :: fxyz12 real(kind=wp), private :: fxyz22 real(kind=wp), private :: fxyzq2","tags":"","loc":"proc/interp_5d.html"},{"title":"interp_6d â€“ finterp","text":"private pure subroutine interp_6d(me, x, y, z, q, r, s, f, istat) 6D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(in) :: s real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized Calls proc~~interp_6d~~CallsGraph proc~interp_6d interp_6d proc~dintrv dintrv proc~interp_6d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ix iy iz iq ir is p1 p2 p3 p4 p5 p6 q1 q2 q3 q4 q5 q6 mflag fx11111 fx21111 fx12111 fx22111 fx11211 fx21211 fx12211 fx22211 fxy1111 fxy2111 fxy1211 fxy2211 fxyz111 fxyz211 fxyzq11 fx11121 fx21121 fx12121 fx22121 fx11221 fx21221 fx12221 fx22221 fxy1121 fxy2121 fxy1221 fxy2221 fxyz121 fxyz221 fxyzq21 fx11112 fx21112 fx12112 fx22112 fx11212 fx21212 fx12212 fx22212 fxy1112 fxy2112 fxy1212 fxy2212 fxyz112 fxyz212 fxyzq12 fx11122 fx21122 fx12122 fx22122 fx11222 fx21222 fx12222 fx22222 fxy1122 fxy2122 fxy1222 fxy2222 fxyz122 fxyz222 fxyzq22 fxyzqr1 fxyzqr2 Variables Type Visibility Attributes Name Initial integer, private, dimension(2) :: ix integer, private, dimension(2) :: iy integer, private, dimension(2) :: iz integer, private, dimension(2) :: iq integer, private, dimension(2) :: ir integer, private, dimension(2) :: is real(kind=wp), private :: p1 real(kind=wp), private :: p2 real(kind=wp), private :: p3 real(kind=wp), private :: p4 real(kind=wp), private :: p5 real(kind=wp), private :: p6 real(kind=wp), private :: q1 real(kind=wp), private :: q2 real(kind=wp), private :: q3 real(kind=wp), private :: q4 real(kind=wp), private :: q5 real(kind=wp), private :: q6 integer, private :: mflag real(kind=wp), private :: fx11111 real(kind=wp), private :: fx21111 real(kind=wp), private :: fx12111 real(kind=wp), private :: fx22111 real(kind=wp), private :: fx11211 real(kind=wp), private :: fx21211 real(kind=wp), private :: fx12211 real(kind=wp), private :: fx22211 real(kind=wp), private :: fxy1111 real(kind=wp), private :: fxy2111 real(kind=wp), private :: fxy1211 real(kind=wp), private :: fxy2211 real(kind=wp), private :: fxyz111 real(kind=wp), private :: fxyz211 real(kind=wp), private :: fxyzq11 real(kind=wp), private :: fx11121 real(kind=wp), private :: fx21121 real(kind=wp), private :: fx12121 real(kind=wp), private :: fx22121 real(kind=wp), private :: fx11221 real(kind=wp), private :: fx21221 real(kind=wp), private :: fx12221 real(kind=wp), private :: fx22221 real(kind=wp), private :: fxy1121 real(kind=wp), private :: fxy2121 real(kind=wp), private :: fxy1221 real(kind=wp), private :: fxy2221 real(kind=wp), private :: fxyz121 real(kind=wp), private :: fxyz221 real(kind=wp), private :: fxyzq21 real(kind=wp), private :: fx11112 real(kind=wp), private :: fx21112 real(kind=wp), private :: fx12112 real(kind=wp), private :: fx22112 real(kind=wp), private :: fx11212 real(kind=wp), private :: fx21212 real(kind=wp), private :: fx12212 real(kind=wp), private :: fx22212 real(kind=wp), private :: fxy1112 real(kind=wp), private :: fxy2112 real(kind=wp), private :: fxy1212 real(kind=wp), private :: fxy2212 real(kind=wp), private :: fxyz112 real(kind=wp), private :: fxyz212 real(kind=wp), private :: fxyzq12 real(kind=wp), private :: fx11122 real(kind=wp), private :: fx21122 real(kind=wp), private :: fx12122 real(kind=wp), private :: fx22122 real(kind=wp), private :: fx11222 real(kind=wp), private :: fx21222 real(kind=wp), private :: fx12222 real(kind=wp), private :: fx22222 real(kind=wp), private :: fxy1122 real(kind=wp), private :: fxy2122 real(kind=wp), private :: fxy1222 real(kind=wp), private :: fxy2222 real(kind=wp), private :: fxyz122 real(kind=wp), private :: fxyz222 real(kind=wp), private :: fxyzq22 real(kind=wp), private :: fxyzqr1 real(kind=wp), private :: fxyzqr2","tags":"","loc":"proc/interp_6d.html"},{"title":"dintrv â€“ finterp","text":"private pure subroutine dintrv(xt, x, ilo, ileft, iright, mflag, inearest) Returns the indices in xt that bound x , to use for interpolation.\n  If outside the range, then the indices are returned that can\n  be used for extrapolation.\n  Precisely, if x < xt ( 1 ) then ileft = 1 , iright = 2 , mflag =- 1 if xt ( i ) <= x < xt ( i + 1 ) then ileft = i , iright = i + 1 , mflag = 0 if xt ( n ) <= x then ileft = n - 1 , iright = n , mflag = 1 History interv written by carl de boor [5] dintrv author: amos, d. e., (snla) : date written 800901 revision date 820801 Jacob Williams, 2/24/2015 : updated to free-form Fortran. Jacob Williams, 2/17/2016 : additional refactoring (eliminated GOTOs). Jacob Williams, 2/22/2016 : modified bspline-fortran dintrv routine for\n    linear interpolation/extrapolation use. Jacob Williams, 10/9/2019 : added optional inearest output. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xt a knot or break point vector real(kind=wp), intent(in) :: x argument integer, intent(inout) :: ilo an initialization parameter which must be set\nto 1 the first time the array xt is\nprocessed by dintrv. ilo contains information for\nefficient processing after the initial call and ilo must not be changed by the user.  each dimension\nrequires a distinct ilo parameter. integer, intent(out) :: ileft left index integer, intent(out) :: iright right index integer, intent(out) :: mflag signals when x lies out of bounds integer, intent(out), optional :: inearest nearest index Called by proc~~dintrv~~CalledByGraph proc~dintrv dintrv proc~nearest_4d nearest_4d proc~nearest_4d->proc~dintrv proc~nearest_2d nearest_2d proc~nearest_2d->proc~dintrv proc~nearest_1d nearest_1d proc~nearest_1d->proc~dintrv proc~nearest_6d nearest_6d proc~nearest_6d->proc~dintrv proc~interp_1d interp_1d proc~interp_1d->proc~dintrv proc~nearest_3d nearest_3d proc~nearest_3d->proc~dintrv proc~interp_3d interp_3d proc~interp_3d->proc~dintrv proc~interp_5d interp_5d proc~interp_5d->proc~dintrv proc~interp_2d interp_2d proc~interp_2d->proc~dintrv proc~interp_4d interp_4d proc~interp_4d->proc~dintrv proc~interp_6d interp_6d proc~interp_6d->proc~dintrv proc~nearest_5d nearest_5d proc~nearest_5d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ihi istep imid n Variables Type Visibility Attributes Name Initial integer, private :: ihi integer, private :: istep integer, private :: imid integer, private :: n","tags":"","loc":"proc/dintrv.html"},{"title":"nearest_1d â€“ finterp","text":"private pure subroutine nearest_1d(me, x, f, istat) 1D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_1d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized Calls proc~~nearest_1d~~CallsGraph proc~nearest_1d nearest_1d proc~dintrv dintrv proc~nearest_1d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables mflag ix i Variables Type Visibility Attributes Name Initial integer, private :: mflag integer, private, dimension(2) :: ix integer, private :: i","tags":"","loc":"proc/nearest_1d.html"},{"title":"nearest_2d â€“ finterp","text":"private pure subroutine nearest_2d(me, x, y, f, istat) 2D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_2d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized Calls proc~~nearest_2d~~CallsGraph proc~nearest_2d nearest_2d proc~dintrv dintrv proc~nearest_2d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables mflag ix iy i j Variables Type Visibility Attributes Name Initial integer, private :: mflag integer, private, dimension(2) :: ix integer, private, dimension(2) :: iy integer, private :: i integer, private :: j","tags":"","loc":"proc/nearest_2d.html"},{"title":"nearest_3d â€“ finterp","text":"private pure subroutine nearest_3d(me, x, y, z, f, istat) 3D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_3d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized Calls proc~~nearest_3d~~CallsGraph proc~nearest_3d nearest_3d proc~dintrv dintrv proc~nearest_3d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables mflag ix iy iz i j k Variables Type Visibility Attributes Name Initial integer, private :: mflag integer, private, dimension(2) :: ix integer, private, dimension(2) :: iy integer, private, dimension(2) :: iz integer, private :: i integer, private :: j integer, private :: k","tags":"","loc":"proc/nearest_3d.html"},{"title":"nearest_4d â€“ finterp","text":"private pure subroutine nearest_4d(me, x, y, z, q, f, istat) 4D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_4d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized Calls proc~~nearest_4d~~CallsGraph proc~nearest_4d nearest_4d proc~dintrv dintrv proc~nearest_4d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables mflag ix iy iz iq i j k l Variables Type Visibility Attributes Name Initial integer, private :: mflag integer, private, dimension(2) :: ix integer, private, dimension(2) :: iy integer, private, dimension(2) :: iz integer, private, dimension(2) :: iq integer, private :: i integer, private :: j integer, private :: k integer, private :: l","tags":"","loc":"proc/nearest_4d.html"},{"title":"nearest_5d â€“ finterp","text":"private pure subroutine nearest_5d(me, x, y, z, q, r, f, istat) 5D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_5d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized Calls proc~~nearest_5d~~CallsGraph proc~nearest_5d nearest_5d proc~dintrv dintrv proc~nearest_5d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables mflag ix iy iz iq ir i j k l m Variables Type Visibility Attributes Name Initial integer, private :: mflag integer, private, dimension(2) :: ix integer, private, dimension(2) :: iy integer, private, dimension(2) :: iz integer, private, dimension(2) :: iq integer, private, dimension(2) :: ir integer, private :: i integer, private :: j integer, private :: k integer, private :: l integer, private :: m","tags":"","loc":"proc/nearest_5d.html"},{"title":"nearest_6d â€“ finterp","text":"private pure subroutine nearest_6d(me, x, y, z, q, r, s, f, istat) 6D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_6d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(in) :: s real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized Calls proc~~nearest_6d~~CallsGraph proc~nearest_6d nearest_6d proc~dintrv dintrv proc~nearest_6d->proc~dintrv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables mflag ix iy iz iq ir is i j k l m n Variables Type Visibility Attributes Name Initial integer, private :: mflag integer, private, dimension(2) :: ix integer, private, dimension(2) :: iy integer, private, dimension(2) :: iz integer, private, dimension(2) :: iq integer, private, dimension(2) :: ir integer, private, dimension(2) :: is integer, private :: i integer, private :: j integer, private :: k integer, private :: l integer, private :: m integer, private :: n","tags":"","loc":"proc/nearest_6d.html"},{"title":"check_inputs â€“ finterp","text":"private pure subroutine check_inputs(me, x, y, z, q, r, s, ierr) Check the validity of the inputs to the initialize routines.\n  Prints warning message if there is an error,\n  and also sets ierr (/=0 if there were any errors). Supports up to 6D: x,y,z,q,r,s History Jacob Williams, 2/24/2015 : Created this routine. Jacob Williams, 2/23/2016 : modified for linear interp module. Arguments Type Intent Optional Attributes Name class( linear_interp_class ), intent(in) :: me real(kind=wp), intent(in), optional dimension(:) :: x x abscissa vector real(kind=wp), intent(in), optional dimension(:) :: y y abscissa vector real(kind=wp), intent(in), optional dimension(:) :: z z abscissa vector real(kind=wp), intent(in), optional dimension(:) :: q q abscissa vector real(kind=wp), intent(in), optional dimension(:) :: r r abscissa vector real(kind=wp), intent(in), optional dimension(:) :: s s abscissa vector integer, intent(out) :: ierr 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 6 : s is not strictly increasing, 100 : cannot use linear interpolation for only one point. Calls proc~~check_inputs~~CallsGraph proc~check_inputs check_inputs none~check check proc~check_inputs->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines check Subroutines pure subroutine check(v, error_code, ierr) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: v abcissae vector integer, intent(in) :: error_code error code for check integer, intent(inout) :: ierr will be set to error_code if there is a problem","tags":"","loc":"proc/check_inputs.html"},{"title":"linear_interpolation_module â€“ finterp","text":"Multidimensional linear interpolation/extrapolation. Uses repeated linear interpolation to evaluate\n functions which have been tabulated at the nodes of an n-dimensional rectangular grid.\n If any coordinate lies outside the range of the corresponding\n variable, then extrapolation is performed using the two nearest points. Uses iso_fortran_env module~~linear_interpolation_module~~UsesGraph module~linear_interpolation_module linear_interpolation_module iso_fortran_env iso_fortran_env module~linear_interpolation_module->iso_fortran_env Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables zero one Abstract Interfaces destroy_func Derived Types linear_interp_class linear_interp_1d linear_interp_2d linear_interp_3d linear_interp_4d linear_interp_5d linear_interp_6d nearest_interp_1d nearest_interp_2d nearest_interp_3d nearest_interp_4d nearest_interp_5d nearest_interp_6d Subroutines finalize_1d finalize_2d finalize_3d finalize_4d finalize_5d finalize_6d destroy_1d destroy_2d destroy_3d destroy_4d destroy_5d destroy_6d initialize_1d initialize_2d initialize_3d initialize_4d initialize_5d initialize_6d interp_1d interp_2d interp_3d interp_4d interp_5d interp_6d dintrv nearest_1d nearest_2d nearest_3d nearest_4d nearest_5d nearest_6d check_inputs Variables Type Visibility Attributes Name Initial real(kind=wp), private, parameter :: zero = 0.0_wp numeric constant real(kind=wp), private, parameter :: one = 1.0_wp numeric constant Abstract Interfaces abstract interface private pure elemental subroutine destroy_func(me) interface for bspline destructor routines Arguments Type Intent Optional Attributes Name class( linear_interp_class ), intent(inout) :: me Derived Types type, private, abstract :: linear_interp_class Base class for the linear interpolation types Components Type Visibility Attributes Name Initial logical, private :: initialized = .false. if the class was properly initialized Type-Bound Procedures procedure(destroy_func), public :: destroy destructor procedure, private :: check_inputs type, private, extends( linear_interp_class ) :: linear_interp_1d Class for 1d linear interpolation. Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x integer, private :: ilox = 1 Finalizations Procedures final :: finalize_1d Type-Bound Procedures procedure, public :: initialize => initialize_1d procedure, public :: evaluate => interp_1d procedure, public :: destroy => destroy_1d type, private, extends( linear_interp_class ) :: linear_interp_2d Class for 2d linear interpolation. Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y integer, private :: ilox = 1 integer, private :: iloy = 1 Finalizations Procedures final :: finalize_2d Type-Bound Procedures procedure, public :: initialize => initialize_2d procedure, public :: evaluate => interp_2d procedure, public :: destroy => destroy_2d type, private, extends( linear_interp_class ) :: linear_interp_3d Class for 3d linear interpolation. Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y real(kind=wp), private, dimension(:), allocatable :: z integer, private :: ilox = 1 integer, private :: iloy = 1 integer, private :: iloz = 1 Finalizations Procedures final :: finalize_3d Type-Bound Procedures procedure, public :: initialize => initialize_3d procedure, public :: evaluate => interp_3d procedure, public :: destroy => destroy_3d type, private, extends( linear_interp_class ) :: linear_interp_4d Class for 4d linear interpolation. Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y real(kind=wp), private, dimension(:), allocatable :: z real(kind=wp), private, dimension(:), allocatable :: q integer, private :: ilox = 1 integer, private :: iloy = 1 integer, private :: iloz = 1 integer, private :: iloq = 1 Finalizations Procedures final :: finalize_4d Type-Bound Procedures procedure, public :: initialize => initialize_4d procedure, public :: evaluate => interp_4d procedure, public :: destroy => destroy_4d type, private, extends( linear_interp_class ) :: linear_interp_5d Class for 5d linear interpolation. Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:,:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y real(kind=wp), private, dimension(:), allocatable :: z real(kind=wp), private, dimension(:), allocatable :: q real(kind=wp), private, dimension(:), allocatable :: r integer, private :: ilox = 1 integer, private :: iloy = 1 integer, private :: iloz = 1 integer, private :: iloq = 1 integer, private :: ilor = 1 Finalizations Procedures final :: finalize_5d Type-Bound Procedures procedure, public :: initialize => initialize_5d procedure, public :: evaluate => interp_5d procedure, public :: destroy => destroy_5d type, private, extends( linear_interp_class ) :: linear_interp_6d Class for 6d linear interpolation. Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:,:,:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y real(kind=wp), private, dimension(:), allocatable :: z real(kind=wp), private, dimension(:), allocatable :: q real(kind=wp), private, dimension(:), allocatable :: r real(kind=wp), private, dimension(:), allocatable :: s integer, private :: ilox = 1 integer, private :: iloy = 1 integer, private :: iloz = 1 integer, private :: iloq = 1 integer, private :: ilor = 1 integer, private :: ilos = 1 Finalizations Procedures final :: finalize_6d Type-Bound Procedures procedure, public :: initialize => initialize_6d procedure, public :: evaluate => interp_6d procedure, public :: destroy => destroy_6d type, public, extends( linear_interp_1d ) :: nearest_interp_1d Class for 1d nearest neighbor interpolation. Type-Bound Procedures procedure, public :: initialize => initialize_1d procedure, public :: destroy => destroy_1d procedure, public :: evaluate => nearest_1d type, public, extends( linear_interp_2d ) :: nearest_interp_2d Class for 2d nearest neighbor interpolation. Type-Bound Procedures procedure, public :: initialize => initialize_2d procedure, public :: destroy => destroy_2d procedure, public :: evaluate => nearest_2d type, public, extends( linear_interp_3d ) :: nearest_interp_3d Class for 3d nearest neighbor interpolation. Type-Bound Procedures procedure, public :: initialize => initialize_3d procedure, public :: destroy => destroy_3d procedure, public :: evaluate => nearest_3d type, public, extends( linear_interp_4d ) :: nearest_interp_4d Class for 4d nearest neighbor interpolation. Type-Bound Procedures procedure, public :: initialize => initialize_4d procedure, public :: destroy => destroy_4d procedure, public :: evaluate => nearest_4d type, public, extends( linear_interp_5d ) :: nearest_interp_5d Class for 5d nearest neighbor interpolation. Type-Bound Procedures procedure, public :: initialize => initialize_5d procedure, public :: destroy => destroy_5d procedure, public :: evaluate => nearest_5d type, public, extends( linear_interp_6d ) :: nearest_interp_6d Class for 6d nearest neighbor interpolation. Type-Bound Procedures procedure, public :: initialize => initialize_6d procedure, public :: destroy => destroy_6d procedure, public :: evaluate => nearest_6d Subroutines private pure elemental subroutine finalize_1d (me) Finalizer for a linear_interp_1d type. Arguments Type Intent Optional Attributes Name type( linear_interp_1d ), intent(inout) :: me private pure elemental subroutine finalize_2d (me) Finalizer for a linear_interp_2d type. Arguments Type Intent Optional Attributes Name type( linear_interp_2d ), intent(inout) :: me private pure elemental subroutine finalize_3d (me) Finalizer for a linear_interp_3d type. Arguments Type Intent Optional Attributes Name type( linear_interp_3d ), intent(inout) :: me private pure elemental subroutine finalize_4d (me) Finalizer for a linear_interp_4d type. Arguments Type Intent Optional Attributes Name type( linear_interp_4d ), intent(inout) :: me private pure elemental subroutine finalize_5d (me) Finalizer for a linear_interp_5d type. Arguments Type Intent Optional Attributes Name type( linear_interp_5d ), intent(inout) :: me private pure elemental subroutine finalize_6d (me) Finalizer for a linear_interp_6d type. Arguments Type Intent Optional Attributes Name type( linear_interp_6d ), intent(inout) :: me private pure elemental subroutine destroy_1d (me) Destructor for a linear_interp_1d class. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me private pure elemental subroutine destroy_2d (me) Destructor for a linear_interp_2d class. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me private pure elemental subroutine destroy_3d (me) Destructor for a linear_interp_3d class. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me private pure elemental subroutine destroy_4d (me) Destructor for a linear_interp_4d class. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me private pure elemental subroutine destroy_5d (me) Destructor for a linear_interp_5d class. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me private pure elemental subroutine destroy_6d (me) Destructor for a linear_interp_6d class. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me private pure subroutine initialize_1d (me, x, f, istat) Constructor for a linear_interp_1d class. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 10 : x is not equal to size(f,1), 100 : cannot use linear interpolation for only one point. private pure subroutine initialize_2d (me, x, y, f, istat) Constructor for a linear_interp_2d class. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 100 : cannot use linear interpolation for only one point. private pure subroutine initialize_3d (me, x, y, z, f, istat) Constructor for a linear_interp_3d class. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 100 : cannot use linear interpolation for only one point. private pure subroutine initialize_4d (me, x, y, z, q, f, istat) Constructor for a linear_interp_4d class. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 100 : cannot use linear interpolation for only one point. private pure subroutine initialize_5d (me, x, y, z, q, r, f, istat) Constructor for a linear_interp_5d class. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 50 : r is not equal to size(f,5), 100 : cannot use linear interpolation for only one point. private pure subroutine initialize_6d (me, x, y, z, q, r, s, f, istat) Constructor for a linear_interp_6d class. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 6 : s is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 50 : r is not equal to size(f,5), 60 : s is not equal to size(f,6), 100 : cannot use linear interpolation for only one point. private pure subroutine interp_1d (me, x, f, istat) 1D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized private pure subroutine interp_2d (me, x, y, f, istat) 2D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized private pure subroutine interp_3d (me, x, y, z, f, istat) 3D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized private pure subroutine interp_4d (me, x, y, z, q, f, istat) 4D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized private pure subroutine interp_5d (me, x, y, z, q, r, f, istat) 5D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized private pure subroutine interp_6d (me, x, y, z, q, r, s, f, istat) 6D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(in) :: s real(kind=wp), intent(out) :: f Interpolated integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized private pure subroutine dintrv (xt, x, ilo, ileft, iright, mflag, inearest) Returns the indices in xt that bound x , to use for interpolation.\n  If outside the range, then the indices are returned that can\n  be used for extrapolation.\n  Precisely, Read moreâ€¦ Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xt a knot or break point vector real(kind=wp), intent(in) :: x argument integer, intent(inout) :: ilo an initialization parameter which must be set\nto 1 the first time the array xt is\nprocessed by dintrv. ilo contains information for\nefficient processing after the initial call and ilo must not be changed by the user.  each dimension\nrequires a distinct ilo parameter. integer, intent(out) :: ileft left index integer, intent(out) :: iright right index integer, intent(out) :: mflag signals when x lies out of bounds integer, intent(out), optional :: inearest nearest index private pure subroutine nearest_1d (me, x, f, istat) 1D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_1d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized private pure subroutine nearest_2d (me, x, y, f, istat) 2D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_2d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized private pure subroutine nearest_3d (me, x, y, z, f, istat) 3D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_3d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized private pure subroutine nearest_4d (me, x, y, z, q, f, istat) 4D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_4d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized private pure subroutine nearest_5d (me, x, y, z, q, r, f, istat) 5D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_5d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized private pure subroutine nearest_6d (me, x, y, z, q, r, s, f, istat) 6D nearest neighbor interpolation routine. Arguments Type Intent Optional Attributes Name class( nearest_interp_6d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(in) :: s real(kind=wp), intent(out) :: f Nearest integer, intent(out), optional :: istat 0 : no problems, -1 : class has not been initialized private pure subroutine check_inputs (me, x, y, z, q, r, s, ierr) Check the validity of the inputs to the initialize routines.\n  Prints warning message if there is an error,\n  and also sets ierr (/=0 if there were any errors). Read moreâ€¦ Arguments Type Intent Optional Attributes Name class( linear_interp_class ), intent(in) :: me real(kind=wp), intent(in), optional dimension(:) :: x x abscissa vector real(kind=wp), intent(in), optional dimension(:) :: y y abscissa vector real(kind=wp), intent(in), optional dimension(:) :: z z abscissa vector real(kind=wp), intent(in), optional dimension(:) :: q q abscissa vector real(kind=wp), intent(in), optional dimension(:) :: r r abscissa vector real(kind=wp), intent(in), optional dimension(:) :: s s abscissa vector integer, intent(out) :: ierr 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 6 : s is not strictly increasing, 100 : cannot use linear interpolation for only one point.","tags":"","loc":"module/linear_interpolation_module.html"}]}