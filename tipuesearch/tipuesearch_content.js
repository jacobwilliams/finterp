var tipuesearch = {"pages":[{"text":"finterp Brief description License The finterp source code and related files and documentation are distributed under a permissive free software license (BSD-style). Developer Info Jacob Williams","tags":"","loc":"index.html","title":" finterp "},{"text":"Modules linear_interpolation_module Source Code linear_interpolation_module.f90 Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  Multidimensional linear interpolation/extrapolation. ! !  Uses repeated linear interpolation to evaluate !  functions f(x), f(x,y), f(x,y,z), f(x,y,z,q), f(x,y,z,q,r), f(x,y,z,q,r,s)  !  which have been tabulated at the nodes of an n-dimensional rectangular grid. !  If any coordinate  (x_i, y_i, ...)  lies outside the range of the corresponding !  variable, then extrapolation is performed using the two nearest points. module linear_interpolation_module use iso_fortran_env , only : wp => real64 ! working precision implicit none private real ( wp ), parameter , private :: one = 1.0_wp !! numeric constant type , public , abstract :: linear_interp_class !! Base class for the linear interpolation types private contains private procedure ( destroy_func ), deferred , public :: destroy !! destructor end type linear_interp_class abstract interface pure elemental subroutine destroy_func ( me ) !! interface for bspline destructor routines import :: linear_interp_class implicit none class ( linear_interp_class ), intent ( inout ) :: me end subroutine destroy_func end interface type , extends ( linear_interp_class ), public :: linear_interp_1d !! Class for 1d linear interpolation. private real ( wp ), dimension (:), allocatable :: f real ( wp ), dimension (:), allocatable :: x integer :: ilox = 1 contains private procedure , public :: initialize => initialize_1d procedure , public :: evaluate => interp_1d procedure , public :: destroy => destroy_1d final :: finalize_1d end type linear_interp_1d type , extends ( linear_interp_class ), public :: linear_interp_2d !! Class for 2d linear interpolation. private real ( wp ), dimension (:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y integer :: ilox = 1 integer :: iloy = 1 contains private procedure , public :: initialize => initialize_2d procedure , public :: evaluate => interp_2d procedure , public :: destroy => destroy_2d final :: finalize_2d end type linear_interp_2d type , extends ( linear_interp_class ), public :: linear_interp_3d !! Class for 3d linear interpolation. private real ( wp ), dimension (:,:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y real ( wp ), dimension (:), allocatable :: z integer :: ilox = 1 integer :: iloy = 1 integer :: iloz = 1 contains private procedure , public :: initialize => initialize_3d procedure , public :: evaluate => interp_3d procedure , public :: destroy => destroy_3d final :: finalize_3d end type linear_interp_3d type , extends ( linear_interp_class ), public :: linear_interp_4d !! Class for 4d linear interpolation. private real ( wp ), dimension (:,:,:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y real ( wp ), dimension (:), allocatable :: z real ( wp ), dimension (:), allocatable :: q integer :: ilox = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 contains private procedure , public :: initialize => initialize_4d procedure , public :: evaluate => interp_4d procedure , public :: destroy => destroy_4d final :: finalize_4d end type linear_interp_4d type , extends ( linear_interp_class ), public :: linear_interp_5d !! Class for 5d linear interpolation. private real ( wp ), dimension (:,:,:,:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y real ( wp ), dimension (:), allocatable :: z real ( wp ), dimension (:), allocatable :: q real ( wp ), dimension (:), allocatable :: r integer :: ilox = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 integer :: ilor = 1 contains private procedure , public :: initialize => initialize_5d procedure , public :: evaluate => interp_5d procedure , public :: destroy => destroy_5d final :: finalize_5d end type linear_interp_5d type , extends ( linear_interp_class ), public :: linear_interp_6d !! Class for 6d linear interpolation. private real ( wp ), dimension (:,:,:,:,:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y real ( wp ), dimension (:), allocatable :: z real ( wp ), dimension (:), allocatable :: q real ( wp ), dimension (:), allocatable :: r real ( wp ), dimension (:), allocatable :: s integer :: ilox = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 integer :: ilor = 1 integer :: ilos = 1 contains private procedure , public :: initialize => initialize_6d procedure , public :: evaluate => interp_6d procedure , public :: destroy => destroy_6d final :: finalize_6d end type linear_interp_6d contains !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for a [[linear_interp_1d]] type. pure elemental subroutine finalize_1d ( me ) implicit none type ( linear_interp_1d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_1d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for a [[linear_interp_2d]] type. pure elemental subroutine finalize_2d ( me ) implicit none type ( linear_interp_2d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_2d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for a [[linear_interp_3d]] type. pure elemental subroutine finalize_3d ( me ) implicit none type ( linear_interp_3d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_3d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for a [[linear_interp_4d]] type. pure elemental subroutine finalize_4d ( me ) implicit none type ( linear_interp_4d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_4d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for a [[linear_interp_5d]] type. pure elemental subroutine finalize_5d ( me ) implicit none type ( linear_interp_5d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_5d !***************************************************************************************** !***************************************************************************************** !> !  Finalizer for a [[linear_interp_6d]] type. pure elemental subroutine finalize_6d ( me ) implicit none type ( linear_interp_6d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_6d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for a [[linear_interp_1d]] class. pure elemental subroutine destroy_1d ( me ) implicit none class ( linear_interp_1d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) me % ilox = 1 end subroutine destroy_1d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for a [[linear_interp_2d]] class. pure elemental subroutine destroy_2d ( me ) implicit none class ( linear_interp_2d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) me % ilox = 1 me % iloy = 1 end subroutine destroy_2d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for a [[linear_interp_3d]] class. pure elemental subroutine destroy_3d ( me ) implicit none class ( linear_interp_3d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) if ( allocated ( me % z )) deallocate ( me % z ) me % ilox = 1 me % iloy = 1 me % iloz = 1 end subroutine destroy_3d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for a [[linear_interp_4d]] class. pure elemental subroutine destroy_4d ( me ) implicit none class ( linear_interp_4d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) if ( allocated ( me % z )) deallocate ( me % z ) if ( allocated ( me % q )) deallocate ( me % q ) me % ilox = 1 me % iloy = 1 me % iloz = 1 me % iloq = 1 end subroutine destroy_4d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for a [[linear_interp_5d]] class. pure elemental subroutine destroy_5d ( me ) implicit none class ( linear_interp_5d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) if ( allocated ( me % z )) deallocate ( me % z ) if ( allocated ( me % q )) deallocate ( me % q ) if ( allocated ( me % r )) deallocate ( me % r ) me % ilox = 1 me % iloy = 1 me % iloz = 1 me % iloq = 1 me % ilor = 1 end subroutine destroy_5d !***************************************************************************************** !***************************************************************************************** !> !  Destructor for a [[linear_interp_6d]] class. pure elemental subroutine destroy_6d ( me ) implicit none class ( linear_interp_6d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) if ( allocated ( me % z )) deallocate ( me % z ) if ( allocated ( me % q )) deallocate ( me % q ) if ( allocated ( me % r )) deallocate ( me % r ) if ( allocated ( me % s )) deallocate ( me % s ) me % ilox = 1 me % iloy = 1 me % iloz = 1 me % iloq = 1 me % ilor = 1 me % ilos = 1 end subroutine destroy_6d !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[linear_interp_1d]] class. pure subroutine initialize_1d ( me , x , f , istat ) implicit none class ( linear_interp_1d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`  : no problems, !! `1`  : `x` is not strictly increasing, !! `10` : `x` is not equal to size(f,1). call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 ) then call check_inputs ( x = x , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x end if end if end subroutine initialize_1d !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[linear_interp_2d]] class. pure subroutine initialize_2d ( me , x , y , f , istat ) implicit none class ( linear_interp_2d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`  : no problems, !! `1`  : `x` is not strictly increasing, !! `2`  : `y` is not strictly increasing, !! `10` : `x` is not equal to size(f,1), !! `20` : `y` is not equal to size(f,2). call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 ) then call check_inputs ( x = x , y = y , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y end if end if end subroutine initialize_2d !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[linear_interp_3d]] class. pure subroutine initialize_3d ( me , x , y , z , f , istat ) implicit none class ( linear_interp_3d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:,:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`  : no problems, !! `1`  : `x` is not strictly increasing, !! `2`  : `y` is not strictly increasing, !! `3`  : `z` is not strictly increasing, !! `10` : `x` is not equal to size(f,1), !! `20` : `y` is not equal to size(f,2), !! `30` : `z` is not equal to size(f,3). call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 . and . size ( z ) /= size ( f , 3 )) istat = 30 if ( istat == 0 ) then call check_inputs ( x = x , y = y , z = z , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ), size ( z ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y allocate ( me % z ( size ( z ))); me % z = z end if end if end subroutine initialize_3d !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[linear_interp_4d]] class. pure subroutine initialize_4d ( me , x , y , z , q , f , istat ) implicit none class ( linear_interp_4d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:,:,:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`  : no problems, !! `1`  : `x` is not strictly increasing, !! `2`  : `y` is not strictly increasing, !! `3`  : `z` is not strictly increasing, !! `4`  : `q` is not strictly increasing, !! `10` : `x` is not equal to size(f,1), !! `20` : `y` is not equal to size(f,2), !! `30` : `z` is not equal to size(f,3), !! `40` : `q` is not equal to size(f,4). call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 . and . size ( z ) /= size ( f , 3 )) istat = 30 if ( istat == 0 . and . size ( q ) /= size ( f , 4 )) istat = 40 if ( istat == 0 ) then call check_inputs ( x = x , y = y , z = z , q = q , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ), size ( z ), size ( q ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y allocate ( me % z ( size ( z ))); me % z = z allocate ( me % q ( size ( q ))); me % q = q end if end if end subroutine initialize_4d !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[linear_interp_5d]] class. pure subroutine initialize_5d ( me , x , y , z , q , r , f , istat ) implicit none class ( linear_interp_5d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:,:,:,:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`  : no problems, !! `1`  : `x` is not strictly increasing, !! `2`  : `y` is not strictly increasing, !! `3`  : `z` is not strictly increasing, !! `4`  : `q` is not strictly increasing, !! `5`  : `r` is not strictly increasing, !! `10` : `x` is not equal to size(f,1), !! `20` : `y` is not equal to size(f,2), !! `30` : `z` is not equal to size(f,3), !! `40` : `q` is not equal to size(f,4), !! `50` : `r` is not equal to size(f,5). call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 . and . size ( z ) /= size ( f , 3 )) istat = 30 if ( istat == 0 . and . size ( q ) /= size ( f , 4 )) istat = 40 if ( istat == 0 . and . size ( r ) /= size ( f , 5 )) istat = 50 if ( istat == 0 ) then call check_inputs ( x = x , y = y , z = z , q = q , r = r , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ), size ( z ), size ( q ), size ( r ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y allocate ( me % z ( size ( z ))); me % z = z allocate ( me % q ( size ( q ))); me % q = q allocate ( me % r ( size ( r ))); me % r = r end if end if end subroutine initialize_5d !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[linear_interp_6d]] class. pure subroutine initialize_6d ( me , x , y , z , q , r , s , f , istat ) implicit none class ( linear_interp_6d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:), intent ( in ) :: s real ( wp ), dimension (:,:,:,:,:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`  : no problems, !! `1`  : `x` is not strictly increasing, !! `2`  : `y` is not strictly increasing, !! `3`  : `z` is not strictly increasing, !! `4`  : `q` is not strictly increasing, !! `5`  : `r` is not strictly increasing, !! `6`  : `s` is not strictly increasing, !! `10` : `x` is not equal to size(f,1), !! `20` : `y` is not equal to size(f,2), !! `30` : `z` is not equal to size(f,3), !! `40` : `q` is not equal to size(f,4), !! `50` : `r` is not equal to size(f,5), !! `60` : `s` is not equal to size(f,6). call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 . and . size ( z ) /= size ( f , 3 )) istat = 30 if ( istat == 0 . and . size ( q ) /= size ( f , 4 )) istat = 40 if ( istat == 0 . and . size ( r ) /= size ( f , 5 )) istat = 50 if ( istat == 0 . and . size ( s ) /= size ( f , 6 )) istat = 60 if ( istat == 0 ) then call check_inputs ( x = x , y = y , z = z , q = q , r = r , s = s , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ), size ( z ), size ( q ), size ( r ), size ( s ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y allocate ( me % z ( size ( z ))); me % z = z allocate ( me % q ( size ( q ))); me % q = q allocate ( me % r ( size ( r ))); me % r = r allocate ( me % s ( size ( s ))); me % s = s end if end if end subroutine initialize_6d !***************************************************************************************** !***************************************************************************************** !> !  1D linear interpolation routine. pure subroutine interp_1d ( me , x , fx ) implicit none class ( linear_interp_1d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( out ) :: fx !! Interpolated  f(x)  integer , dimension ( 2 ) :: ix real ( wp ) :: p1 real ( wp ) :: q1 integer :: mflag call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) p1 = one - q1 fx = p1 * me % f ( ix ( 1 )) + q1 * me % f ( ix ( 2 )) end subroutine interp_1d !***************************************************************************************** !***************************************************************************************** !> !  2D linear interpolation routine. pure subroutine interp_2d ( me , x , y , fxy ) implicit none class ( linear_interp_2d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( out ) :: fxy !! Interpolated  f(x,y)  integer , dimension ( 2 ) :: ix , iy real ( wp ) :: p1 , p2 real ( wp ) :: q1 , q2 integer :: mflag real ( wp ) :: fx1 , fx2 call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) p1 = one - q1 p2 = one - q2 fx1 = p1 * me % f ( ix ( 1 ), iy ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 )) fx2 = p1 * me % f ( ix ( 1 ), iy ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 )) fxy = p2 * ( fx1 ) + q2 * ( fx2 ) end subroutine interp_2d !***************************************************************************************** !***************************************************************************************** !> !  3D linear interpolation routine. pure subroutine interp_3d ( me , x , y , z , fxyz ) implicit none class ( linear_interp_3d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( out ) :: fxyz !! Interpolated  f(x,y,z)  integer , dimension ( 2 ) :: ix , iy , iz real ( wp ) :: p1 , p2 , p3 real ( wp ) :: q1 , q2 , q3 integer :: mflag real ( wp ) :: fx11 , fx21 , fx12 , fx22 , fxy1 , fxy2 call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) q3 = ( z - me % z ( iz ( 1 ))) / ( me % z ( iz ( 2 )) - me % z ( iz ( 1 ))) p1 = one - q1 p2 = one - q2 p3 = one - q3 fx11 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 )) fx21 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 )) fx12 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 )) fx22 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 )) fxy1 = p2 * ( fx11 ) + q2 * ( fx21 ) fxy2 = p2 * ( fx12 ) + q2 * ( fx22 ) fxyz = p3 * ( fxy1 ) + q3 * ( fxy2 ) end subroutine interp_3d !***************************************************************************************** !***************************************************************************************** !> !  4D linear interpolation routine. pure subroutine interp_4d ( me , x , y , z , q , fxyzq ) implicit none class ( linear_interp_4d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( in ) :: q real ( wp ), intent ( out ) :: fxyzq !! Interpolated  f(x,y,z,q)  integer , dimension ( 2 ) :: ix , iy , iz , iq real ( wp ) :: p1 , p2 , p3 , p4 real ( wp ) :: q1 , q2 , q3 , q4 integer :: mflag real ( wp ) :: fx111 , fx211 , fx121 , fx221 , fxy11 , fxy21 , fxyz1 ,& fx112 , fx212 , fx122 , fx222 , fxy12 , fxy22 , fxyz2 call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag ) call dintrv ( me % q , q , me % iloq , iq ( 1 ), iq ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) q3 = ( z - me % z ( iz ( 1 ))) / ( me % z ( iz ( 2 )) - me % z ( iz ( 1 ))) q4 = ( q - me % q ( iq ( 1 ))) / ( me % q ( iq ( 2 )) - me % q ( iq ( 1 ))) p1 = one - q1 p2 = one - q2 p3 = one - q3 p4 = one - q4 fx111 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 )) fx211 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 )) fx121 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 )) fx221 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 )) fx112 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 )) fx212 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 )) fx122 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 )) fx222 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 )) fxy11 = p2 * fx111 + q2 * fx211 fxy21 = p2 * fx121 + q2 * fx221 fxy12 = p2 * fx112 + q2 * fx212 fxy22 = p2 * fx122 + q2 * fx222 fxyz1 = p3 * fxy11 + q3 * fxy21 fxyz2 = p3 * fxy12 + q3 * fxy22 fxyzq = p4 * fxyz1 + q4 * fxyz2 end subroutine interp_4d !***************************************************************************************** !***************************************************************************************** !> !  5D linear interpolation routine. pure subroutine interp_5d ( me , x , y , z , q , r , fxyzqr ) implicit none class ( linear_interp_5d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( in ) :: q real ( wp ), intent ( in ) :: r real ( wp ), intent ( out ) :: fxyzqr !! Interpolated  f(x,y,z,q,r)  integer , dimension ( 2 ) :: ix , iy , iz , iq , ir real ( wp ) :: p1 , p2 , p3 , p4 , p5 real ( wp ) :: q1 , q2 , q3 , q4 , q5 integer :: mflag real ( wp ) :: fx1111 , fx2111 , fx1211 , fx2211 , fx1121 , fx2121 , fx1221 , fx2221 , & fxy111 , fxy211 , fxy121 , fxy221 , fxyz11 , fxyz21 , fxyzq1 , fx1112 , & fx2112 , fx1212 , fx2212 , fx1122 , fx2122 , fx1222 , fx2222 , fxy112 , & fxy212 , fxy122 , fxy222 , fxyz12 , fxyz22 , fxyzq2 call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag ) call dintrv ( me % q , q , me % iloq , iq ( 1 ), iq ( 2 ), mflag ) call dintrv ( me % r , r , me % ilor , ir ( 1 ), ir ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) q3 = ( z - me % z ( iz ( 1 ))) / ( me % z ( iz ( 2 )) - me % z ( iz ( 1 ))) q4 = ( q - me % q ( iq ( 1 ))) / ( me % q ( iq ( 2 )) - me % q ( iq ( 1 ))) q5 = ( r - me % r ( ir ( 1 ))) / ( me % r ( ir ( 2 )) - me % r ( ir ( 1 ))) p1 = one - q1 p2 = one - q2 p3 = one - q3 p4 = one - q4 p5 = one - q5 fx1111 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 )) fx2111 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 )) fx1211 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 )) fx2211 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 )) fx1121 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 )) fx2121 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 )) fx1221 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 )) fx2221 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 )) fx1112 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 )) fx2112 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 )) fx1212 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 )) fx2212 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 )) fx1122 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 )) fx2122 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 )) fx1222 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 )) fx2222 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 )) fxy111 = p2 * ( fx1111 ) + q2 * ( fx2111 ) fxy211 = p2 * ( fx1211 ) + q2 * ( fx2211 ) fxy121 = p2 * ( fx1121 ) + q2 * ( fx2121 ) fxy221 = p2 * ( fx1221 ) + q2 * ( fx2221 ) fxy112 = p2 * ( fx1112 ) + q2 * ( fx2112 ) fxy212 = p2 * ( fx1212 ) + q2 * ( fx2212 ) fxy122 = p2 * ( fx1122 ) + q2 * ( fx2122 ) fxy222 = p2 * ( fx1222 ) + q2 * ( fx2222 ) fxyz11 = p3 * ( fxy111 ) + q3 * ( fxy211 ) fxyz21 = p3 * ( fxy121 ) + q3 * ( fxy221 ) fxyz12 = p3 * ( fxy112 ) + q3 * ( fxy212 ) fxyz22 = p3 * ( fxy122 ) + q3 * ( fxy222 ) fxyzq1 = p4 * ( fxyz11 ) + q4 * ( fxyz21 ) fxyzq2 = p4 * ( fxyz12 ) + q4 * ( fxyz22 ) fxyzqr = p5 * fxyzq1 + q5 * fxyzq2 end subroutine interp_5d !***************************************************************************************** !***************************************************************************************** !> !  6D linear interpolation routine. pure subroutine interp_6d ( me , x , y , z , q , r , s , fxyzqrs ) implicit none class ( linear_interp_6d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( in ) :: q real ( wp ), intent ( in ) :: r real ( wp ), intent ( in ) :: s real ( wp ), intent ( out ) :: fxyzqrs !! Interpolated  f(x,y,z,q,r,s)  integer , dimension ( 2 ) :: ix , iy , iz , iq , ir , is real ( wp ) :: p1 , p2 , p3 , p4 , p5 , p6 real ( wp ) :: q1 , q2 , q3 , q4 , q5 , q6 integer :: mflag real ( wp ) :: fx11111 , fx21111 , fx12111 , fx22111 , fx11211 , fx21211 , fx12211 , & fx22211 , fxy1111 , fxy2111 , fxy1211 , fxy2211 , fxyz111 , fxyz211 , & fxyzq11 , fx11121 , fx21121 , fx12121 , fx22121 , fx11221 , fx21221 , & fx12221 , fx22221 , fxy1121 , fxy2121 , fxy1221 , fxy2221 , fxyz121 , & fxyz221 , fxyzq21 , fx11112 , fx21112 , fx12112 , fx22112 , fx11212 , & fx21212 , fx12212 , fx22212 , fxy1112 , fxy2112 , fxy1212 , fxy2212 , & fxyz112 , fxyz212 , fxyzq12 , fx11122 , fx21122 , fx12122 , fx22122 , & fx11222 , fx21222 , fx12222 , fx22222 , fxy1122 , fxy2122 , fxy1222 , & fxy2222 , fxyz122 , fxyz222 , fxyzq22 , fxyzqr1 , fxyzqr2 call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag ) call dintrv ( me % q , q , me % iloq , iq ( 1 ), iq ( 2 ), mflag ) call dintrv ( me % r , r , me % ilor , ir ( 1 ), ir ( 2 ), mflag ) call dintrv ( me % s , s , me % ilos , is ( 1 ), is ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) q3 = ( z - me % z ( iz ( 1 ))) / ( me % z ( iz ( 2 )) - me % z ( iz ( 1 ))) q4 = ( q - me % q ( iq ( 1 ))) / ( me % q ( iq ( 2 )) - me % q ( iq ( 1 ))) q5 = ( r - me % r ( ir ( 1 ))) / ( me % r ( ir ( 2 )) - me % r ( ir ( 1 ))) q6 = ( s - me % s ( is ( 1 ))) / ( me % s ( is ( 2 )) - me % s ( is ( 1 ))) p1 = one - q1 p2 = one - q2 p3 = one - q3 p4 = one - q4 p5 = one - q5 p6 = one - q6 fx11111 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 1 )) fx21111 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 1 )) fx12111 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 1 )) fx22111 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 1 )) fx11211 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 1 )) fx21211 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 1 )) fx12211 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 1 )) fx22211 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 1 )) fx11121 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 1 )) fx21121 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 1 )) fx12121 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 1 )) fx22121 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 1 )) fx11221 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 1 )) fx21221 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 1 )) fx12221 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 1 )) fx22221 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 1 )) fx11112 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 2 )) fx21112 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 2 )) fx12112 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 2 )) fx22112 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 2 )) fx11212 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 2 )) fx21212 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 2 )) fx12212 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 2 )) fx22212 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 2 )) fx11122 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 2 )) fx21122 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 2 )) fx12122 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 2 )) fx22122 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 2 )) fx11222 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 2 )) fx21222 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 2 )) fx12222 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 2 )) fx22222 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 2 )) fxy1111 = p2 * ( fx11111 ) + q2 * ( fx21111 ) fxy2111 = p2 * ( fx12111 ) + q2 * ( fx22111 ) fxy1211 = p2 * ( fx11211 ) + q2 * ( fx21211 ) fxy2211 = p2 * ( fx12211 ) + q2 * ( fx22211 ) fxy1121 = p2 * ( fx11121 ) + q2 * ( fx21121 ) fxy2121 = p2 * ( fx12121 ) + q2 * ( fx22121 ) fxy1221 = p2 * ( fx11221 ) + q2 * ( fx21221 ) fxy2221 = p2 * ( fx12221 ) + q2 * ( fx22221 ) fxy1112 = p2 * ( fx11112 ) + q2 * ( fx21112 ) fxy2112 = p2 * ( fx12112 ) + q2 * ( fx22112 ) fxy1212 = p2 * ( fx11212 ) + q2 * ( fx21212 ) fxy2212 = p2 * ( fx12212 ) + q2 * ( fx22212 ) fxy1122 = p2 * ( fx11122 ) + q2 * ( fx21122 ) fxy2122 = p2 * ( fx12122 ) + q2 * ( fx22122 ) fxy1222 = p2 * ( fx11222 ) + q2 * ( fx21222 ) fxy2222 = p2 * ( fx12222 ) + q2 * ( fx22222 ) fxyz111 = p3 * ( fxy1111 ) + q3 * ( fxy2111 ) fxyz211 = p3 * ( fxy1211 ) + q3 * ( fxy2211 ) fxyz121 = p3 * ( fxy1121 ) + q3 * ( fxy2121 ) fxyz221 = p3 * ( fxy1221 ) + q3 * ( fxy2221 ) fxyz112 = p3 * ( fxy1112 ) + q3 * ( fxy2112 ) fxyz212 = p3 * ( fxy1212 ) + q3 * ( fxy2212 ) fxyz122 = p3 * ( fxy1122 ) + q3 * ( fxy2122 ) fxyz222 = p3 * ( fxy1222 ) + q3 * ( fxy2222 ) fxyzq11 = p4 * ( fxyz111 ) + q4 * ( fxyz211 ) fxyzq21 = p4 * ( fxyz121 ) + q4 * ( fxyz221 ) fxyzq12 = p4 * ( fxyz112 ) + q4 * ( fxyz212 ) fxyzq22 = p4 * ( fxyz122 ) + q4 * ( fxyz222 ) fxyzqr1 = p5 * fxyzq11 + q5 * fxyzq21 fxyzqr2 = p5 * fxyzq12 + q5 * fxyzq22 fxyzqrs = p6 * fxyzqr1 + q6 * fxyzqr2 end subroutine interp_6d !***************************************************************************************** !***************************************************************************************** !> !  Returns the indices in `xt` that bound `x`, to use for interpolation. !  If outside the range, then the indices are returned that can !  be used for extrapolation. !  Precisely, ! !```fortran !         if            x < xt(1)   then ileft=1,   iright=2,    mflag=-1 !         if   xt(i) <= x < xt(i+1) then ileft=i,   iright=i+1,  mflag=0 !         if   xt(n) <= x           then ileft=n-1, iright=n,    mflag=1 !``` ! !### History ! !  * interv written by carl de boor [5] !  * dintrv author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * Jacob Williams, 2/24/2015 : updated to free-form Fortran. !  * Jacob Williams, 2/17/2016 : additional refactoring (eliminated GOTOs). !  * Jacob Williams, 2/22/2016 : modified bspline-fortran `dintrv` routine for !    linear interpolation/extrapolation use. pure subroutine dintrv ( xt , x , ilo , ileft , iright , mflag ) implicit none real ( wp ), dimension (:), intent ( in ) :: xt !! a knot or break point vector real ( wp ), intent ( in ) :: x !! argument integer , intent ( inout ) :: ilo !! an initialization parameter which must be set !! to 1 the first time the array `xt` is !! processed by dintrv. `ilo` contains information for !! efficient processing after the initial call and `ilo` !! must not be changed by the user.  each dimension !! requires a distinct `ilo` parameter. integer , intent ( out ) :: ileft !! left index integer , intent ( out ) :: iright !! right index integer , intent ( out ) :: mflag !! signals when `x` lies out of bounds integer :: ihi , istep , imid , n n = size ( xt ) ihi = ilo + 1 if ( ihi >= n ) then if ( x >= xt ( n ) ) then mflag = 1 ileft = n - 1 iright = n return end if if ( n <= 1 ) then mflag = - 1 ileft = 1 iright = 2 return end if ilo = n - 1 ihi = n endif if ( x >= xt ( ihi ) ) then ! now x >= xt(ilo). find upper bound istep = 1 do ilo = ihi ihi = ilo + istep if ( ihi >= n ) then if ( x >= xt ( n ) ) then mflag = 1 ileft = n - 1 iright = n return end if ihi = n elseif ( x >= xt ( ihi ) ) then istep = istep * 2 cycle endif exit end do else if ( x >= xt ( ilo ) ) then mflag = 0 ileft = ilo iright = ilo + 1 return end if ! now x <= xt(ihi). find lower bound istep = 1 do ihi = ilo ilo = ihi - istep if ( ilo <= 1 ) then ilo = 1 if ( x < xt ( 1 ) ) then mflag = - 1 ileft = 1 iright = 2 return end if elseif ( x < xt ( ilo ) ) then istep = istep * 2 cycle endif exit end do endif ! now xt(ilo) <= x < xt(ihi). narrow the interval do imid = ( ilo + ihi ) / 2 if ( imid == ilo ) then mflag = 0 ileft = ilo iright = ilo + 1 return end if ! note. it is assumed that imid = ilo in case ihi = ilo+1 if ( x < xt ( imid ) ) then ihi = imid else ilo = imid endif end do end subroutine dintrv !***************************************************************************************** !***************************************************************************************** !> !  Returns true if all the elements in the array `x` are unique. !  Note: the array must be sorted. ! !@note This routine is not currently used in the module. pure function check_if_unique ( x ) result ( unique ) implicit none real ( wp ), dimension (:), intent ( in ) :: x !! a sorted array logical :: unique !! true if all elements are unique integer :: i !! counter unique = . true . ! initialize do i = 1 , size ( x ) - 1 if ( x ( i ) == x ( i + 1 )) then unique = . false . exit end if end do end function check_if_unique !***************************************************************************************** !***************************************************************************************** !> !  Sorts an array `dx` in increasing order, !  carrying along an additional array `dy`. ! !  Uses a non-recursive quicksort, reverting to insertion sort on arrays of !  size <= 20. Dimension of `stack` limits array size to about 2&#94;32. ! !### License !  * [Original LAPACK license](http://www.netlib.org/lapack/LICENSE.txt) ! !### History !  * Based on the LAPACK routine [DLASRT](http://www.netlib.org/lapack/explore-html/df/ddf/dlasrt_8f.html). !  * Extensively modified by Jacob Williams, Feb. 2016. Converted to !    modern Fortran and added the `dy` output. Removed the descending sort option. ! !@note This routine is not currently used in the module. pure subroutine sort ( dx , dy ) implicit none real ( wp ), dimension (:), intent ( inout ) :: dx !! on entry, the array to be sorted. !! on exit, `dx` has been sorted into increasing order !! (`dx(1) <= ... <= dx(n)`) or into decreasing order !! (`dx(1) >= ... >= dx(n)`), depending on `id`. real ( wp ), dimension (:), intent ( inout ) :: dy !! array carried along with `dx`. integer , parameter :: select = 20 !! max size for using insertion sort. integer :: endd , i , j , n , start , stkpnt real ( wp ) :: d1 , d2 , d3 , dmnmx , dmnmy , tmp integer , dimension ( 2 , 32 ) :: stack ! number of elements to sort: n = size ( dx ) if ( n > 1 ) then stkpnt = 1 stack ( 1 , 1 ) = 1 stack ( 2 , 1 ) = n do start = stack ( 1 , stkpnt ) endd = stack ( 2 , stkpnt ) stkpnt = stkpnt - 1 if ( endd - start <= select . and . endd > start ) then ! do insertion sort on dx( start:endd ) insertion : do i = start + 1 , endd do j = i , start + 1 , - 1 if ( dx ( j ) >= dx ( j - 1 ) ) cycle insertion dmnmx = dx ( j ) dx ( j ) = dx ( j - 1 ) dx ( j - 1 ) = dmnmx dmnmy = dy ( j ) dy ( j ) = dy ( j - 1 ) dy ( j - 1 ) = dmnmy enddo enddo insertion elseif ( endd - start > select ) then ! partition dx( start:endd ) and stack parts, largest one first ! choose partition entry as median of 3 d1 = dx ( start ) d2 = dx ( endd ) i = ( start + endd ) / 2 d3 = dx ( i ) if ( d1 < d2 ) then if ( d3 < d1 ) then dmnmx = d1 elseif ( d3 < d2 ) then dmnmx = d3 else dmnmx = d2 endif elseif ( d3 < d2 ) then dmnmx = d2 elseif ( d3 < d1 ) then dmnmx = d3 else dmnmx = d1 endif i = start - 1 j = endd + 1 do do j = j - 1 if ( dx ( j ) <= dmnmx ) exit end do do i = i + 1 if ( dx ( i ) >= dmnmx ) exit end do if ( i < j ) then tmp = dx ( i ) dx ( i ) = dx ( j ) dx ( j ) = tmp tmp = dy ( i ) dy ( i ) = dy ( j ) dy ( j ) = tmp else exit endif end do if ( j - start > endd - j - 1 ) then stkpnt = stkpnt + 1 stack ( 1 , stkpnt ) = start stack ( 2 , stkpnt ) = j stkpnt = stkpnt + 1 stack ( 1 , stkpnt ) = j + 1 stack ( 2 , stkpnt ) = endd else stkpnt = stkpnt + 1 stack ( 1 , stkpnt ) = j + 1 stack ( 2 , stkpnt ) = endd stkpnt = stkpnt + 1 stack ( 1 , stkpnt ) = start stack ( 2 , stkpnt ) = j endif endif if ( stkpnt <= 0 ) exit end do end if end subroutine sort !***************************************************************************************** !***************************************************************************************** !> !  Check the validity of the inputs to the initialize routines. !  Prints warning message if there is an error, !  and also sets `ierr` (/=0 if there were any errors). ! !  Supports up to 6D: x,y,z,q,r,s ! !# History !  * Jacob Williams, 2/24/2015 : Created this routine. !  * Jacob Williams, 2/23/2016 : modified for linear interp module. pure subroutine check_inputs ( x , y , z , q , r , s , ierr ) use iso_fortran_env , only : error_unit implicit none real ( wp ), dimension (:), intent ( in ), optional :: x !! `x` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: y !! `y` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: z !! `z` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: q !! `q` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: r !! `r` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: s !! `s` abscissa vector integer , intent ( out ) :: ierr !! `0` : no problems, !! `1` : `x` is not strictly increasing, !! `2` : `y` is not strictly increasing, !! `3` : `z` is not strictly increasing, !! `4` : `q` is not strictly increasing, !! `5` : `r` is not strictly increasing, !! `6` : `s` is not strictly increasing, ierr = 0 ! initialize if ( present ( x )) call check ( x , 1 , ierr ); if ( ierr /= 0 ) return if ( present ( y )) call check ( y , 2 , ierr ); if ( ierr /= 0 ) return if ( present ( z )) call check ( z , 3 , ierr ); if ( ierr /= 0 ) return if ( present ( q )) call check ( q , 4 , ierr ); if ( ierr /= 0 ) return if ( present ( r )) call check ( r , 5 , ierr ); if ( ierr /= 0 ) return if ( present ( s )) call check ( s , 6 , ierr ); if ( ierr /= 0 ) return contains !***************************************************************************************** pure subroutine check ( v , error_code , ierr ) implicit none real ( wp ), dimension (:), intent ( in ) :: v !! abcissae vector integer , intent ( in ) :: error_code !! error code for check integer , intent ( inout ) :: ierr !! will be set to `error_code` if there is a problem integer :: i !! counter integer :: n !! size of the input `v` array n = size ( v ) do i = 2 , n if ( v ( i ) <= v ( i - 1 )) then ierr = error_code exit end if end do end subroutine check end subroutine check_inputs !***************************************************************************************** !***************************************************************************************** end module linear_interpolation_module !*****************************************************************************************","tags":"","loc":"sourcefile/linear_interpolation_module.f90.html","title":"linear_interpolation_module.f90  finterp"},{"text":"Programs linear_interpolation_test Source Code test.f90 Source Code !***************************************************************************************** ! !> Units test for 2d-6d linear interpolation. program linear_interpolation_test use linear_interpolation_module use , intrinsic :: iso_fortran_env , only : wp => real64 implicit none integer , parameter :: nx = 6 !! number of points in x integer , parameter :: ny = 6 !! number of points in y integer , parameter :: nz = 6 !! number of points in z integer , parameter :: nq = 6 !! number of points in q integer , parameter :: nr = 6 !! number of points in r integer , parameter :: ns = 6 !! number of points in s real ( wp ) :: x ( nx ), y ( ny ), z ( nz ), q ( nq ), r ( nr ), s ( ns ) real ( wp ) :: fcn_1d ( nx ) real ( wp ) :: fcn_2d ( nx , ny ) real ( wp ) :: fcn_3d ( nx , ny , nz ) real ( wp ) :: fcn_4d ( nx , ny , nz , nq ) real ( wp ) :: fcn_5d ( nx , ny , nz , nq , nr ) real ( wp ) :: fcn_6d ( nx , ny , nz , nq , nr , ns ) type ( linear_interp_1d ) :: s1 type ( linear_interp_2d ) :: s2 type ( linear_interp_3d ) :: s3 type ( linear_interp_4d ) :: s4 type ( linear_interp_5d ) :: s5 type ( linear_interp_6d ) :: s6 real ( wp ) :: tol , rnd real ( wp ), dimension ( 6 ) :: val , tru , err , errmax logical :: fail integer :: i , j , k , l , m , n , idx , idy , idz , idq , idr , ids integer , dimension ( 6 ) :: iflag fail = . false . tol = 1.0e-14_wp do i = 1 , nx x ( i ) = dble ( i - 1 ) / dble ( nx - 1 ) end do do j = 1 , ny y ( j ) = dble ( j - 1 ) / dble ( ny - 1 ) end do do k = 1 , nz z ( k ) = dble ( k - 1 ) / dble ( nz - 1 ) end do do l = 1 , nq q ( l ) = dble ( l - 1 ) / dble ( nq - 1 ) end do do m = 1 , nr r ( m ) = dble ( m - 1 ) / dble ( nr - 1 ) end do do n = 1 , ns s ( n ) = dble ( n - 1 ) / dble ( ns - 1 ) end do do i = 1 , nx fcn_1d ( i ) = f1 ( x ( i )) do j = 1 , ny fcn_2d ( i , j ) = f2 ( x ( i ), y ( j )) do k = 1 , nz fcn_3d ( i , j , k ) = f3 ( x ( i ), y ( j ), z ( k )) do l = 1 , nq fcn_4d ( i , j , k , l ) = f4 ( x ( i ), y ( j ), z ( k ), q ( l )) do m = 1 , nr fcn_5d ( i , j , k , l , m ) = f5 ( x ( i ), y ( j ), z ( k ), q ( l ), r ( m )) do n = 1 , ns fcn_6d ( i , j , k , l , m , n ) = f6 ( x ( i ), y ( j ), z ( k ), q ( l ), r ( m ), s ( n )) end do end do end do end do end do end do ! initialize call s1 % initialize ( x , fcn_1d , iflag ( 1 )) call s2 % initialize ( x , y , fcn_2d , iflag ( 2 )) call s3 % initialize ( x , y , z , fcn_3d , iflag ( 3 )) call s4 % initialize ( x , y , z , q , fcn_4d , iflag ( 4 )) call s5 % initialize ( x , y , z , q , r , fcn_5d , iflag ( 5 )) call s6 % initialize ( x , y , z , q , r , s , fcn_6d , iflag ( 6 )) if ( any ( iflag /= 0 )) then do i = 1 , 6 if ( iflag ( i ) /= 0 ) then write ( * , * ) 'Error initializing ' , i , 'D interpolator. iflag=' , iflag ( i ) end if end do stop 1 end if ! compute max error at interpolation points errmax = 0.0_wp do i = 1 , nx call RANDOM_NUMBER ( rnd ); rnd = ( rnd - 0.5_wp ) / 10 0.0_wp call s1 % evaluate ( x ( i ) + rnd , val ( 1 )) tru ( 1 ) = f1 ( x ( i ) + rnd ) err ( 1 ) = abs ( tru ( 1 ) - val ( 1 )) errmax ( 1 ) = max ( err ( 1 ), errmax ( 1 )) do j = 1 , ny call RANDOM_NUMBER ( rnd ); rnd = rnd / 10 0.0_wp call s2 % evaluate ( x ( i ) + rnd , y ( j ) + rnd , val ( 2 )) tru ( 2 ) = f2 ( x ( i ) + rnd , y ( j ) + rnd ) err ( 2 ) = abs ( tru ( 2 ) - val ( 2 )) errmax ( 2 ) = max ( err ( 2 ), errmax ( 2 )) do k = 1 , nz call RANDOM_NUMBER ( rnd ); rnd = rnd / 10 0.0_wp call s3 % evaluate ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , val ( 3 )) tru ( 3 ) = f3 ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd ) err ( 3 ) = abs ( tru ( 3 ) - val ( 3 )) errmax ( 3 ) = max ( err ( 3 ), errmax ( 3 )) do l = 1 , nq call RANDOM_NUMBER ( rnd ); rnd = rnd / 10 0.0_wp call s4 % evaluate ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , q ( l ) + rnd , val ( 4 )) tru ( 4 ) = f4 ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , q ( l ) + rnd ) err ( 4 ) = abs ( tru ( 4 ) - val ( 4 )) errmax ( 4 ) = max ( err ( 4 ), errmax ( 4 )) do m = 1 , nr call RANDOM_NUMBER ( rnd ); rnd = rnd / 10 0.0_wp call s5 % evaluate ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , q ( l ) + rnd , r ( m ) + rnd , val ( 5 )) tru ( 5 ) = f5 ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , q ( l ) + rnd , r ( m ) + rnd ) err ( 5 ) = abs ( tru ( 5 ) - val ( 5 )) errmax ( 5 ) = max ( err ( 5 ), errmax ( 5 )) do n = 1 , ns call RANDOM_NUMBER ( rnd ); rnd = rnd / 10 0.0_wp call s6 % evaluate ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , q ( l ) + rnd , r ( m ) + rnd , s ( n ) + rnd , val ( 6 )) tru ( 6 ) = f6 ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , q ( l ) + rnd , r ( m ) + rnd , s ( n ) + rnd ) err ( 6 ) = abs ( tru ( 6 ) - val ( 6 )) errmax ( 6 ) = max ( err ( 6 ), errmax ( 6 )) end do end do end do end do end do end do ! check max error against tolerance do i = 1 , 6 write ( * , * ) i , 'D: max error:' , errmax ( i ) if ( errmax ( i ) >= tol ) then write ( * , * ) ' ** test failed ** ' else write ( * , * ) ' ** test passed ** ' end if write ( * , * ) '' end do contains real ( wp ) function f1 ( x ) !! 1d test function implicit none real ( wp ), intent ( in ) :: x f1 = x + x + x + x + x + x end function f1 real ( wp ) function f2 ( x , y ) !! 2d test function implicit none real ( wp ), intent ( in ) :: x , y f2 = x + y + x + y + x + y end function f2 real ( wp ) function f3 ( x , y , z ) !! 3d test function implicit none real ( wp ), intent ( in ) :: x , y , z f3 = x + y + z + x + y + z end function f3 real ( wp ) function f4 ( x , y , z , q ) !! 4d test function implicit none real ( wp ), intent ( in ) :: x , y , z , q f4 = x + y + z + q + x + y end function f4 real ( wp ) function f5 ( x , y , z , q , r ) !! 5d test function implicit none real ( wp ), intent ( in ) :: x , y , z , q , r f5 = x + y + z + q + r + x end function f5 real ( wp ) function f6 ( x , y , z , q , r , s ) !! 6d test function implicit none real ( wp ), intent ( in ) :: x , y , z , q , r , s f6 = x + y + z + q + r + s end function f6 end program linear_interpolation_test","tags":"","loc":"sourcefile/test.f90.html","title":"test.f90  finterp"},{"text":"type, public, abstract :: linear_interp_class Base class for the linear interpolation types Type-Bound Procedures destroy Source Code linear_interp_class Type-Bound Procedures procedure( destroy_func ), public, deferred :: destroy destructor pure elemental subroutine destroy_func (me) Prototype interface for bspline destructor routines Arguments Type Intent Optional Attributes Name class( linear_interp_class ), intent(inout) :: me Source Code type , public , abstract :: linear_interp_class !! Base class for the linear interpolation types private contains private procedure ( destroy_func ), deferred , public :: destroy !! destructor end type linear_interp_class","tags":"","loc":"type/linear_interp_class.html","title":"linear_interp_class  finterp "},{"text":"type, public, extends( linear_interp_class ) :: linear_interp_1d Class for 1d linear interpolation. Variables f x ilox Finalization Procedures finalize_1d Type-Bound Procedures initialize evaluate destroy Source Code linear_interp_1d Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x integer, private :: ilox = 1 Finalization Procedures final :: finalize_1d private pure elemental subroutine finalize_1d (me) Finalizer for a linear_interp_1d type. Arguments Type Intent Optional Attributes Name type( linear_interp_1d ), intent(inout) :: me Type-Bound Procedures procedure, public :: initialize => initialize_1d private pure subroutine initialize_1d (me, x, f, istat) Constructor for a linear_interp_1d class. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 10 : x is not equal to size(f,1). procedure, public :: evaluate => interp_1d private pure subroutine interp_1d (me, x, fx) 1D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: fx Interpolated  f(x)  procedure, public :: destroy => destroy_1d private pure elemental subroutine destroy_1d (me) Destructor for a linear_interp_1d class. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me Source Code type , extends ( linear_interp_class ), public :: linear_interp_1d !! Class for 1d linear interpolation. private real ( wp ), dimension (:), allocatable :: f real ( wp ), dimension (:), allocatable :: x integer :: ilox = 1 contains private procedure , public :: initialize => initialize_1d procedure , public :: evaluate => interp_1d procedure , public :: destroy => destroy_1d final :: finalize_1d end type linear_interp_1d","tags":"","loc":"type/linear_interp_1d.html","title":"linear_interp_1d  finterp "},{"text":"type, public, extends( linear_interp_class ) :: linear_interp_2d Class for 2d linear interpolation. Variables f x y ilox iloy Finalization Procedures finalize_2d Type-Bound Procedures initialize evaluate destroy Source Code linear_interp_2d Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y integer, private :: ilox = 1 integer, private :: iloy = 1 Finalization Procedures final :: finalize_2d private pure elemental subroutine finalize_2d (me) Finalizer for a linear_interp_2d type. Arguments Type Intent Optional Attributes Name type( linear_interp_2d ), intent(inout) :: me Type-Bound Procedures procedure, public :: initialize => initialize_2d private pure subroutine initialize_2d (me, x, y, f, istat) Constructor for a linear_interp_2d class. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2). procedure, public :: evaluate => interp_2d private pure subroutine interp_2d (me, x, y, fxy) 2D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(out) :: fxy Interpolated  f(x,y)  procedure, public :: destroy => destroy_2d private pure elemental subroutine destroy_2d (me) Destructor for a linear_interp_2d class. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me Source Code type , extends ( linear_interp_class ), public :: linear_interp_2d !! Class for 2d linear interpolation. private real ( wp ), dimension (:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y integer :: ilox = 1 integer :: iloy = 1 contains private procedure , public :: initialize => initialize_2d procedure , public :: evaluate => interp_2d procedure , public :: destroy => destroy_2d final :: finalize_2d end type linear_interp_2d","tags":"","loc":"type/linear_interp_2d.html","title":"linear_interp_2d  finterp "},{"text":"type, public, extends( linear_interp_class ) :: linear_interp_3d Class for 3d linear interpolation. Variables f x y z ilox iloy iloz Finalization Procedures finalize_3d Type-Bound Procedures initialize evaluate destroy Source Code linear_interp_3d Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y real(kind=wp), private, dimension(:), allocatable :: z integer, private :: ilox = 1 integer, private :: iloy = 1 integer, private :: iloz = 1 Finalization Procedures final :: finalize_3d private pure elemental subroutine finalize_3d (me) Finalizer for a linear_interp_3d type. Arguments Type Intent Optional Attributes Name type( linear_interp_3d ), intent(inout) :: me Type-Bound Procedures procedure, public :: initialize => initialize_3d private pure subroutine initialize_3d (me, x, y, z, f, istat) Constructor for a linear_interp_3d class. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3). procedure, public :: evaluate => interp_3d private pure subroutine interp_3d (me, x, y, z, fxyz) 3D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(out) :: fxyz Interpolated  f(x,y,z)  procedure, public :: destroy => destroy_3d private pure elemental subroutine destroy_3d (me) Destructor for a linear_interp_3d class. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me Source Code type , extends ( linear_interp_class ), public :: linear_interp_3d !! Class for 3d linear interpolation. private real ( wp ), dimension (:,:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y real ( wp ), dimension (:), allocatable :: z integer :: ilox = 1 integer :: iloy = 1 integer :: iloz = 1 contains private procedure , public :: initialize => initialize_3d procedure , public :: evaluate => interp_3d procedure , public :: destroy => destroy_3d final :: finalize_3d end type linear_interp_3d","tags":"","loc":"type/linear_interp_3d.html","title":"linear_interp_3d  finterp "},{"text":"type, public, extends( linear_interp_class ) :: linear_interp_4d Class for 4d linear interpolation. Variables f x y z q ilox iloy iloz iloq Finalization Procedures finalize_4d Type-Bound Procedures initialize evaluate destroy Source Code linear_interp_4d Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y real(kind=wp), private, dimension(:), allocatable :: z real(kind=wp), private, dimension(:), allocatable :: q integer, private :: ilox = 1 integer, private :: iloy = 1 integer, private :: iloz = 1 integer, private :: iloq = 1 Finalization Procedures final :: finalize_4d private pure elemental subroutine finalize_4d (me) Finalizer for a linear_interp_4d type. Arguments Type Intent Optional Attributes Name type( linear_interp_4d ), intent(inout) :: me Type-Bound Procedures procedure, public :: initialize => initialize_4d private pure subroutine initialize_4d (me, x, y, z, q, f, istat) Constructor for a linear_interp_4d class. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4). procedure, public :: evaluate => interp_4d private pure subroutine interp_4d (me, x, y, z, q, fxyzq) 4D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(out) :: fxyzq Interpolated  f(x,y,z,q)  procedure, public :: destroy => destroy_4d private pure elemental subroutine destroy_4d (me) Destructor for a linear_interp_4d class. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me Source Code type , extends ( linear_interp_class ), public :: linear_interp_4d !! Class for 4d linear interpolation. private real ( wp ), dimension (:,:,:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y real ( wp ), dimension (:), allocatable :: z real ( wp ), dimension (:), allocatable :: q integer :: ilox = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 contains private procedure , public :: initialize => initialize_4d procedure , public :: evaluate => interp_4d procedure , public :: destroy => destroy_4d final :: finalize_4d end type linear_interp_4d","tags":"","loc":"type/linear_interp_4d.html","title":"linear_interp_4d  finterp "},{"text":"type, public, extends( linear_interp_class ) :: linear_interp_5d Class for 5d linear interpolation. Variables f x y z q r ilox iloy iloz iloq ilor Finalization Procedures finalize_5d Type-Bound Procedures initialize evaluate destroy Source Code linear_interp_5d Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:,:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y real(kind=wp), private, dimension(:), allocatable :: z real(kind=wp), private, dimension(:), allocatable :: q real(kind=wp), private, dimension(:), allocatable :: r integer, private :: ilox = 1 integer, private :: iloy = 1 integer, private :: iloz = 1 integer, private :: iloq = 1 integer, private :: ilor = 1 Finalization Procedures final :: finalize_5d private pure elemental subroutine finalize_5d (me) Finalizer for a linear_interp_5d type. Arguments Type Intent Optional Attributes Name type( linear_interp_5d ), intent(inout) :: me Type-Bound Procedures procedure, public :: initialize => initialize_5d private pure subroutine initialize_5d (me, x, y, z, q, r, f, istat) Constructor for a linear_interp_5d class. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 50 : r is not equal to size(f,5). procedure, public :: evaluate => interp_5d private pure subroutine interp_5d (me, x, y, z, q, r, fxyzqr) 5D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: fxyzqr Interpolated  f(x,y,z,q,r)  procedure, public :: destroy => destroy_5d private pure elemental subroutine destroy_5d (me) Destructor for a linear_interp_5d class. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me Source Code type , extends ( linear_interp_class ), public :: linear_interp_5d !! Class for 5d linear interpolation. private real ( wp ), dimension (:,:,:,:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y real ( wp ), dimension (:), allocatable :: z real ( wp ), dimension (:), allocatable :: q real ( wp ), dimension (:), allocatable :: r integer :: ilox = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 integer :: ilor = 1 contains private procedure , public :: initialize => initialize_5d procedure , public :: evaluate => interp_5d procedure , public :: destroy => destroy_5d final :: finalize_5d end type linear_interp_5d","tags":"","loc":"type/linear_interp_5d.html","title":"linear_interp_5d  finterp "},{"text":"type, public, extends( linear_interp_class ) :: linear_interp_6d Class for 6d linear interpolation. Variables f x y z q r s ilox iloy iloz iloq ilor ilos Finalization Procedures finalize_6d Type-Bound Procedures initialize evaluate destroy Source Code linear_interp_6d Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:,:,:,:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x real(kind=wp), private, dimension(:), allocatable :: y real(kind=wp), private, dimension(:), allocatable :: z real(kind=wp), private, dimension(:), allocatable :: q real(kind=wp), private, dimension(:), allocatable :: r real(kind=wp), private, dimension(:), allocatable :: s integer, private :: ilox = 1 integer, private :: iloy = 1 integer, private :: iloz = 1 integer, private :: iloq = 1 integer, private :: ilor = 1 integer, private :: ilos = 1 Finalization Procedures final :: finalize_6d private pure elemental subroutine finalize_6d (me) Finalizer for a linear_interp_6d type. Arguments Type Intent Optional Attributes Name type( linear_interp_6d ), intent(inout) :: me Type-Bound Procedures procedure, public :: initialize => initialize_6d private pure subroutine initialize_6d (me, x, y, z, q, r, s, f, istat) Constructor for a linear_interp_6d class. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 6 : s is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 50 : r is not equal to size(f,5), 60 : s is not equal to size(f,6). procedure, public :: evaluate => interp_6d private pure subroutine interp_6d (me, x, y, z, q, r, s, fxyzqrs) 6D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(in) :: s real(kind=wp), intent(out) :: fxyzqrs Interpolated  f(x,y,z,q,r,s)  procedure, public :: destroy => destroy_6d private pure elemental subroutine destroy_6d (me) Destructor for a linear_interp_6d class. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me Source Code type , extends ( linear_interp_class ), public :: linear_interp_6d !! Class for 6d linear interpolation. private real ( wp ), dimension (:,:,:,:,:,:), allocatable :: f real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension (:), allocatable :: y real ( wp ), dimension (:), allocatable :: z real ( wp ), dimension (:), allocatable :: q real ( wp ), dimension (:), allocatable :: r real ( wp ), dimension (:), allocatable :: s integer :: ilox = 1 integer :: iloy = 1 integer :: iloz = 1 integer :: iloq = 1 integer :: ilor = 1 integer :: ilos = 1 contains private procedure , public :: initialize => initialize_6d procedure , public :: evaluate => interp_6d procedure , public :: destroy => destroy_6d final :: finalize_6d end type linear_interp_6d","tags":"","loc":"type/linear_interp_6d.html","title":"linear_interp_6d  finterp "},{"text":"abstract interface private pure elemental subroutine destroy_func(me) Arguments Type Intent Optional Attributes Name class( linear_interp_class ), intent(inout) :: me Description interface for bspline destructor routines","tags":"","loc":"interface/destroy_func.html","title":"destroy_func  finterp"},{"text":"private pure function check_if_unique(x) result(unique) Returns true if all the elements in the array x are unique.\n  Note: the array must be sorted. Note This routine is not currently used in the module. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x a sorted array Return Value logical true if all elements are unique Source Code check_if_unique Source Code pure function check_if_unique ( x ) result ( unique ) implicit none real ( wp ), dimension (:), intent ( in ) :: x !! a sorted array logical :: unique !! true if all elements are unique integer :: i !! counter unique = . true . ! initialize do i = 1 , size ( x ) - 1 if ( x ( i ) == x ( i + 1 )) then unique = . false . exit end if end do end function check_if_unique","tags":"","loc":"proc/check_if_unique.html","title":"check_if_unique  finterp"},{"text":"private pure elemental subroutine finalize_1d(me) Finalizer for a linear_interp_1d type. Arguments Type Intent Optional Attributes Name type( linear_interp_1d ), intent(inout) :: me Source Code finalize_1d Source Code pure elemental subroutine finalize_1d ( me ) implicit none type ( linear_interp_1d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_1d","tags":"","loc":"proc/finalize_1d.html","title":"finalize_1d  finterp"},{"text":"private pure elemental subroutine finalize_2d(me) Finalizer for a linear_interp_2d type. Arguments Type Intent Optional Attributes Name type( linear_interp_2d ), intent(inout) :: me Source Code finalize_2d Source Code pure elemental subroutine finalize_2d ( me ) implicit none type ( linear_interp_2d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_2d","tags":"","loc":"proc/finalize_2d.html","title":"finalize_2d  finterp"},{"text":"private pure elemental subroutine finalize_3d(me) Finalizer for a linear_interp_3d type. Arguments Type Intent Optional Attributes Name type( linear_interp_3d ), intent(inout) :: me Source Code finalize_3d Source Code pure elemental subroutine finalize_3d ( me ) implicit none type ( linear_interp_3d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_3d","tags":"","loc":"proc/finalize_3d.html","title":"finalize_3d  finterp"},{"text":"private pure elemental subroutine finalize_4d(me) Finalizer for a linear_interp_4d type. Arguments Type Intent Optional Attributes Name type( linear_interp_4d ), intent(inout) :: me Source Code finalize_4d Source Code pure elemental subroutine finalize_4d ( me ) implicit none type ( linear_interp_4d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_4d","tags":"","loc":"proc/finalize_4d.html","title":"finalize_4d  finterp"},{"text":"private pure elemental subroutine finalize_5d(me) Finalizer for a linear_interp_5d type. Arguments Type Intent Optional Attributes Name type( linear_interp_5d ), intent(inout) :: me Source Code finalize_5d Source Code pure elemental subroutine finalize_5d ( me ) implicit none type ( linear_interp_5d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_5d","tags":"","loc":"proc/finalize_5d.html","title":"finalize_5d  finterp"},{"text":"private pure elemental subroutine finalize_6d(me) Finalizer for a linear_interp_6d type. Arguments Type Intent Optional Attributes Name type( linear_interp_6d ), intent(inout) :: me Source Code finalize_6d Source Code pure elemental subroutine finalize_6d ( me ) implicit none type ( linear_interp_6d ), intent ( inout ) :: me call me % destroy () end subroutine finalize_6d","tags":"","loc":"proc/finalize_6d.html","title":"finalize_6d  finterp"},{"text":"private pure elemental subroutine destroy_1d(me) Destructor for a linear_interp_1d class. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me Source Code destroy_1d Source Code pure elemental subroutine destroy_1d ( me ) implicit none class ( linear_interp_1d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) me % ilox = 1 end subroutine destroy_1d","tags":"","loc":"proc/destroy_1d.html","title":"destroy_1d  finterp"},{"text":"private pure elemental subroutine destroy_2d(me) Destructor for a linear_interp_2d class. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me Source Code destroy_2d Source Code pure elemental subroutine destroy_2d ( me ) implicit none class ( linear_interp_2d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) me % ilox = 1 me % iloy = 1 end subroutine destroy_2d","tags":"","loc":"proc/destroy_2d.html","title":"destroy_2d  finterp"},{"text":"private pure elemental subroutine destroy_3d(me) Destructor for a linear_interp_3d class. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me Source Code destroy_3d Source Code pure elemental subroutine destroy_3d ( me ) implicit none class ( linear_interp_3d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) if ( allocated ( me % z )) deallocate ( me % z ) me % ilox = 1 me % iloy = 1 me % iloz = 1 end subroutine destroy_3d","tags":"","loc":"proc/destroy_3d.html","title":"destroy_3d  finterp"},{"text":"private pure elemental subroutine destroy_4d(me) Destructor for a linear_interp_4d class. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me Source Code destroy_4d Source Code pure elemental subroutine destroy_4d ( me ) implicit none class ( linear_interp_4d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) if ( allocated ( me % z )) deallocate ( me % z ) if ( allocated ( me % q )) deallocate ( me % q ) me % ilox = 1 me % iloy = 1 me % iloz = 1 me % iloq = 1 end subroutine destroy_4d","tags":"","loc":"proc/destroy_4d.html","title":"destroy_4d  finterp"},{"text":"private pure elemental subroutine destroy_5d(me) Destructor for a linear_interp_5d class. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me Source Code destroy_5d Source Code pure elemental subroutine destroy_5d ( me ) implicit none class ( linear_interp_5d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) if ( allocated ( me % z )) deallocate ( me % z ) if ( allocated ( me % q )) deallocate ( me % q ) if ( allocated ( me % r )) deallocate ( me % r ) me % ilox = 1 me % iloy = 1 me % iloz = 1 me % iloq = 1 me % ilor = 1 end subroutine destroy_5d","tags":"","loc":"proc/destroy_5d.html","title":"destroy_5d  finterp"},{"text":"private pure elemental subroutine destroy_6d(me) Destructor for a linear_interp_6d class. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me Source Code destroy_6d Source Code pure elemental subroutine destroy_6d ( me ) implicit none class ( linear_interp_6d ), intent ( inout ) :: me if ( allocated ( me % f )) deallocate ( me % f ) if ( allocated ( me % x )) deallocate ( me % x ) if ( allocated ( me % y )) deallocate ( me % y ) if ( allocated ( me % z )) deallocate ( me % z ) if ( allocated ( me % q )) deallocate ( me % q ) if ( allocated ( me % r )) deallocate ( me % r ) if ( allocated ( me % s )) deallocate ( me % s ) me % ilox = 1 me % iloy = 1 me % iloz = 1 me % iloq = 1 me % ilor = 1 me % ilos = 1 end subroutine destroy_6d","tags":"","loc":"proc/destroy_6d.html","title":"destroy_6d  finterp"},{"text":"private pure subroutine initialize_1d(me, x, f, istat) Constructor for a linear_interp_1d class. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 10 : x is not equal to size(f,1). Source Code initialize_1d Source Code pure subroutine initialize_1d ( me , x , f , istat ) implicit none class ( linear_interp_1d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`  : no problems, !! `1`  : `x` is not strictly increasing, !! `10` : `x` is not equal to size(f,1). call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 ) then call check_inputs ( x = x , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x end if end if end subroutine initialize_1d","tags":"","loc":"proc/initialize_1d.html","title":"initialize_1d  finterp"},{"text":"private pure subroutine initialize_2d(me, x, y, f, istat) Constructor for a linear_interp_2d class. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2). Source Code initialize_2d Source Code pure subroutine initialize_2d ( me , x , y , f , istat ) implicit none class ( linear_interp_2d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`  : no problems, !! `1`  : `x` is not strictly increasing, !! `2`  : `y` is not strictly increasing, !! `10` : `x` is not equal to size(f,1), !! `20` : `y` is not equal to size(f,2). call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 ) then call check_inputs ( x = x , y = y , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y end if end if end subroutine initialize_2d","tags":"","loc":"proc/initialize_2d.html","title":"initialize_2d  finterp"},{"text":"private pure subroutine initialize_3d(me, x, y, z, f, istat) Constructor for a linear_interp_3d class. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3). Source Code initialize_3d Source Code pure subroutine initialize_3d ( me , x , y , z , f , istat ) implicit none class ( linear_interp_3d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:,:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`  : no problems, !! `1`  : `x` is not strictly increasing, !! `2`  : `y` is not strictly increasing, !! `3`  : `z` is not strictly increasing, !! `10` : `x` is not equal to size(f,1), !! `20` : `y` is not equal to size(f,2), !! `30` : `z` is not equal to size(f,3). call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 . and . size ( z ) /= size ( f , 3 )) istat = 30 if ( istat == 0 ) then call check_inputs ( x = x , y = y , z = z , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ), size ( z ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y allocate ( me % z ( size ( z ))); me % z = z end if end if end subroutine initialize_3d","tags":"","loc":"proc/initialize_3d.html","title":"initialize_3d  finterp"},{"text":"private pure subroutine initialize_4d(me, x, y, z, q, f, istat) Constructor for a linear_interp_4d class. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4). Source Code initialize_4d Source Code pure subroutine initialize_4d ( me , x , y , z , q , f , istat ) implicit none class ( linear_interp_4d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:,:,:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`  : no problems, !! `1`  : `x` is not strictly increasing, !! `2`  : `y` is not strictly increasing, !! `3`  : `z` is not strictly increasing, !! `4`  : `q` is not strictly increasing, !! `10` : `x` is not equal to size(f,1), !! `20` : `y` is not equal to size(f,2), !! `30` : `z` is not equal to size(f,3), !! `40` : `q` is not equal to size(f,4). call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 . and . size ( z ) /= size ( f , 3 )) istat = 30 if ( istat == 0 . and . size ( q ) /= size ( f , 4 )) istat = 40 if ( istat == 0 ) then call check_inputs ( x = x , y = y , z = z , q = q , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ), size ( z ), size ( q ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y allocate ( me % z ( size ( z ))); me % z = z allocate ( me % q ( size ( q ))); me % q = q end if end if end subroutine initialize_4d","tags":"","loc":"proc/initialize_4d.html","title":"initialize_4d  finterp"},{"text":"private pure subroutine initialize_5d(me, x, y, z, q, r, f, istat) Constructor for a linear_interp_5d class. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:,:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 50 : r is not equal to size(f,5). Source Code initialize_5d Source Code pure subroutine initialize_5d ( me , x , y , z , q , r , f , istat ) implicit none class ( linear_interp_5d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:,:,:,:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`  : no problems, !! `1`  : `x` is not strictly increasing, !! `2`  : `y` is not strictly increasing, !! `3`  : `z` is not strictly increasing, !! `4`  : `q` is not strictly increasing, !! `5`  : `r` is not strictly increasing, !! `10` : `x` is not equal to size(f,1), !! `20` : `y` is not equal to size(f,2), !! `30` : `z` is not equal to size(f,3), !! `40` : `q` is not equal to size(f,4), !! `50` : `r` is not equal to size(f,5). call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 . and . size ( z ) /= size ( f , 3 )) istat = 30 if ( istat == 0 . and . size ( q ) /= size ( f , 4 )) istat = 40 if ( istat == 0 . and . size ( r ) /= size ( f , 5 )) istat = 50 if ( istat == 0 ) then call check_inputs ( x = x , y = y , z = z , q = q , r = r , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ), size ( z ), size ( q ), size ( r ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y allocate ( me % z ( size ( z ))); me % z = z allocate ( me % q ( size ( q ))); me % q = q allocate ( me % r ( size ( r ))); me % r = r end if end if end subroutine initialize_5d","tags":"","loc":"proc/initialize_5d.html","title":"initialize_5d  finterp"},{"text":"private pure subroutine initialize_6d(me, x, y, z, q, r, s, f, istat) Constructor for a linear_interp_6d class. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: z real(kind=wp), intent(in), dimension(:) :: q real(kind=wp), intent(in), dimension(:) :: r real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: f integer, intent(out) :: istat 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 6 : s is not strictly increasing, 10 : x is not equal to size(f,1), 20 : y is not equal to size(f,2), 30 : z is not equal to size(f,3), 40 : q is not equal to size(f,4), 50 : r is not equal to size(f,5), 60 : s is not equal to size(f,6). Source Code initialize_6d Source Code pure subroutine initialize_6d ( me , x , y , z , q , r , s , f , istat ) implicit none class ( linear_interp_6d ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: z real ( wp ), dimension (:), intent ( in ) :: q real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension (:), intent ( in ) :: s real ( wp ), dimension (:,:,:,:,:,:), intent ( in ) :: f integer , intent ( out ) :: istat !! `0`  : no problems, !! `1`  : `x` is not strictly increasing, !! `2`  : `y` is not strictly increasing, !! `3`  : `z` is not strictly increasing, !! `4`  : `q` is not strictly increasing, !! `5`  : `r` is not strictly increasing, !! `6`  : `s` is not strictly increasing, !! `10` : `x` is not equal to size(f,1), !! `20` : `y` is not equal to size(f,2), !! `30` : `z` is not equal to size(f,3), !! `40` : `q` is not equal to size(f,4), !! `50` : `r` is not equal to size(f,5), !! `60` : `s` is not equal to size(f,6). call me % destroy () istat = 0 if ( istat == 0 . and . size ( x ) /= size ( f , 1 )) istat = 10 if ( istat == 0 . and . size ( y ) /= size ( f , 2 )) istat = 20 if ( istat == 0 . and . size ( z ) /= size ( f , 3 )) istat = 30 if ( istat == 0 . and . size ( q ) /= size ( f , 4 )) istat = 40 if ( istat == 0 . and . size ( r ) /= size ( f , 5 )) istat = 50 if ( istat == 0 . and . size ( s ) /= size ( f , 6 )) istat = 60 if ( istat == 0 ) then call check_inputs ( x = x , y = y , z = z , q = q , r = r , s = s , ierr = istat ) if ( istat == 0 ) then allocate ( me % f ( size ( x ), size ( y ), size ( z ), size ( q ), size ( r ), size ( s ))); me % f = f allocate ( me % x ( size ( x ))); me % x = x allocate ( me % y ( size ( y ))); me % y = y allocate ( me % z ( size ( z ))); me % z = z allocate ( me % q ( size ( q ))); me % q = q allocate ( me % r ( size ( r ))); me % r = r allocate ( me % s ( size ( s ))); me % s = s end if end if end subroutine initialize_6d","tags":"","loc":"proc/initialize_6d.html","title":"initialize_6d  finterp"},{"text":"private pure subroutine interp_1d(me, x, fx) 1D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_1d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: fx Interpolated  f(x)  Source Code interp_1d Source Code pure subroutine interp_1d ( me , x , fx ) implicit none class ( linear_interp_1d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( out ) :: fx !! Interpolated  f(x)  integer , dimension ( 2 ) :: ix real ( wp ) :: p1 real ( wp ) :: q1 integer :: mflag call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) p1 = one - q1 fx = p1 * me % f ( ix ( 1 )) + q1 * me % f ( ix ( 2 )) end subroutine interp_1d","tags":"","loc":"proc/interp_1d.html","title":"interp_1d  finterp"},{"text":"private pure subroutine interp_2d(me, x, y, fxy) 2D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_2d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(out) :: fxy Interpolated  f(x,y)  Source Code interp_2d Source Code pure subroutine interp_2d ( me , x , y , fxy ) implicit none class ( linear_interp_2d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( out ) :: fxy !! Interpolated  f(x,y)  integer , dimension ( 2 ) :: ix , iy real ( wp ) :: p1 , p2 real ( wp ) :: q1 , q2 integer :: mflag real ( wp ) :: fx1 , fx2 call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) p1 = one - q1 p2 = one - q2 fx1 = p1 * me % f ( ix ( 1 ), iy ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 )) fx2 = p1 * me % f ( ix ( 1 ), iy ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 )) fxy = p2 * ( fx1 ) + q2 * ( fx2 ) end subroutine interp_2d","tags":"","loc":"proc/interp_2d.html","title":"interp_2d  finterp"},{"text":"private pure subroutine interp_3d(me, x, y, z, fxyz) 3D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_3d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(out) :: fxyz Interpolated  f(x,y,z)  Source Code interp_3d Source Code pure subroutine interp_3d ( me , x , y , z , fxyz ) implicit none class ( linear_interp_3d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( out ) :: fxyz !! Interpolated  f(x,y,z)  integer , dimension ( 2 ) :: ix , iy , iz real ( wp ) :: p1 , p2 , p3 real ( wp ) :: q1 , q2 , q3 integer :: mflag real ( wp ) :: fx11 , fx21 , fx12 , fx22 , fxy1 , fxy2 call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) q3 = ( z - me % z ( iz ( 1 ))) / ( me % z ( iz ( 2 )) - me % z ( iz ( 1 ))) p1 = one - q1 p2 = one - q2 p3 = one - q3 fx11 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 )) fx21 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 )) fx12 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 )) fx22 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 )) fxy1 = p2 * ( fx11 ) + q2 * ( fx21 ) fxy2 = p2 * ( fx12 ) + q2 * ( fx22 ) fxyz = p3 * ( fxy1 ) + q3 * ( fxy2 ) end subroutine interp_3d","tags":"","loc":"proc/interp_3d.html","title":"interp_3d  finterp"},{"text":"private pure subroutine interp_4d(me, x, y, z, q, fxyzq) 4D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_4d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(out) :: fxyzq Interpolated  f(x,y,z,q)  Source Code interp_4d Source Code pure subroutine interp_4d ( me , x , y , z , q , fxyzq ) implicit none class ( linear_interp_4d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( in ) :: q real ( wp ), intent ( out ) :: fxyzq !! Interpolated  f(x,y,z,q)  integer , dimension ( 2 ) :: ix , iy , iz , iq real ( wp ) :: p1 , p2 , p3 , p4 real ( wp ) :: q1 , q2 , q3 , q4 integer :: mflag real ( wp ) :: fx111 , fx211 , fx121 , fx221 , fxy11 , fxy21 , fxyz1 ,& fx112 , fx212 , fx122 , fx222 , fxy12 , fxy22 , fxyz2 call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag ) call dintrv ( me % q , q , me % iloq , iq ( 1 ), iq ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) q3 = ( z - me % z ( iz ( 1 ))) / ( me % z ( iz ( 2 )) - me % z ( iz ( 1 ))) q4 = ( q - me % q ( iq ( 1 ))) / ( me % q ( iq ( 2 )) - me % q ( iq ( 1 ))) p1 = one - q1 p2 = one - q2 p3 = one - q3 p4 = one - q4 fx111 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 )) fx211 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 )) fx121 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 )) fx221 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 )) fx112 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 )) fx212 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 )) fx122 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 )) fx222 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 )) fxy11 = p2 * fx111 + q2 * fx211 fxy21 = p2 * fx121 + q2 * fx221 fxy12 = p2 * fx112 + q2 * fx212 fxy22 = p2 * fx122 + q2 * fx222 fxyz1 = p3 * fxy11 + q3 * fxy21 fxyz2 = p3 * fxy12 + q3 * fxy22 fxyzq = p4 * fxyz1 + q4 * fxyz2 end subroutine interp_4d","tags":"","loc":"proc/interp_4d.html","title":"interp_4d  finterp"},{"text":"private pure subroutine interp_5d(me, x, y, z, q, r, fxyzqr) 5D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_5d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: fxyzqr Interpolated  f(x,y,z,q,r)  Source Code interp_5d Source Code pure subroutine interp_5d ( me , x , y , z , q , r , fxyzqr ) implicit none class ( linear_interp_5d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( in ) :: q real ( wp ), intent ( in ) :: r real ( wp ), intent ( out ) :: fxyzqr !! Interpolated  f(x,y,z,q,r)  integer , dimension ( 2 ) :: ix , iy , iz , iq , ir real ( wp ) :: p1 , p2 , p3 , p4 , p5 real ( wp ) :: q1 , q2 , q3 , q4 , q5 integer :: mflag real ( wp ) :: fx1111 , fx2111 , fx1211 , fx2211 , fx1121 , fx2121 , fx1221 , fx2221 , & fxy111 , fxy211 , fxy121 , fxy221 , fxyz11 , fxyz21 , fxyzq1 , fx1112 , & fx2112 , fx1212 , fx2212 , fx1122 , fx2122 , fx1222 , fx2222 , fxy112 , & fxy212 , fxy122 , fxy222 , fxyz12 , fxyz22 , fxyzq2 call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag ) call dintrv ( me % q , q , me % iloq , iq ( 1 ), iq ( 2 ), mflag ) call dintrv ( me % r , r , me % ilor , ir ( 1 ), ir ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) q3 = ( z - me % z ( iz ( 1 ))) / ( me % z ( iz ( 2 )) - me % z ( iz ( 1 ))) q4 = ( q - me % q ( iq ( 1 ))) / ( me % q ( iq ( 2 )) - me % q ( iq ( 1 ))) q5 = ( r - me % r ( ir ( 1 ))) / ( me % r ( ir ( 2 )) - me % r ( ir ( 1 ))) p1 = one - q1 p2 = one - q2 p3 = one - q3 p4 = one - q4 p5 = one - q5 fx1111 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 )) fx2111 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 )) fx1211 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 )) fx2211 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 )) fx1121 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 )) fx2121 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 )) fx1221 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 )) fx2221 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 )) fx1112 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 )) fx2112 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 )) fx1212 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 )) fx2212 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 )) fx1122 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 )) fx2122 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 )) fx1222 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 )) fx2222 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 )) fxy111 = p2 * ( fx1111 ) + q2 * ( fx2111 ) fxy211 = p2 * ( fx1211 ) + q2 * ( fx2211 ) fxy121 = p2 * ( fx1121 ) + q2 * ( fx2121 ) fxy221 = p2 * ( fx1221 ) + q2 * ( fx2221 ) fxy112 = p2 * ( fx1112 ) + q2 * ( fx2112 ) fxy212 = p2 * ( fx1212 ) + q2 * ( fx2212 ) fxy122 = p2 * ( fx1122 ) + q2 * ( fx2122 ) fxy222 = p2 * ( fx1222 ) + q2 * ( fx2222 ) fxyz11 = p3 * ( fxy111 ) + q3 * ( fxy211 ) fxyz21 = p3 * ( fxy121 ) + q3 * ( fxy221 ) fxyz12 = p3 * ( fxy112 ) + q3 * ( fxy212 ) fxyz22 = p3 * ( fxy122 ) + q3 * ( fxy222 ) fxyzq1 = p4 * ( fxyz11 ) + q4 * ( fxyz21 ) fxyzq2 = p4 * ( fxyz12 ) + q4 * ( fxyz22 ) fxyzqr = p5 * fxyzq1 + q5 * fxyzq2 end subroutine interp_5d","tags":"","loc":"proc/interp_5d.html","title":"interp_5d  finterp"},{"text":"private pure subroutine interp_6d(me, x, y, z, q, r, s, fxyzqrs) 6D linear interpolation routine. Arguments Type Intent Optional Attributes Name class( linear_interp_6d ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(in) :: s real(kind=wp), intent(out) :: fxyzqrs Interpolated  f(x,y,z,q,r,s)  Source Code interp_6d Source Code pure subroutine interp_6d ( me , x , y , z , q , r , s , fxyzqrs ) implicit none class ( linear_interp_6d ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y real ( wp ), intent ( in ) :: z real ( wp ), intent ( in ) :: q real ( wp ), intent ( in ) :: r real ( wp ), intent ( in ) :: s real ( wp ), intent ( out ) :: fxyzqrs !! Interpolated  f(x,y,z,q,r,s)  integer , dimension ( 2 ) :: ix , iy , iz , iq , ir , is real ( wp ) :: p1 , p2 , p3 , p4 , p5 , p6 real ( wp ) :: q1 , q2 , q3 , q4 , q5 , q6 integer :: mflag real ( wp ) :: fx11111 , fx21111 , fx12111 , fx22111 , fx11211 , fx21211 , fx12211 , & fx22211 , fxy1111 , fxy2111 , fxy1211 , fxy2211 , fxyz111 , fxyz211 , & fxyzq11 , fx11121 , fx21121 , fx12121 , fx22121 , fx11221 , fx21221 , & fx12221 , fx22221 , fxy1121 , fxy2121 , fxy1221 , fxy2221 , fxyz121 , & fxyz221 , fxyzq21 , fx11112 , fx21112 , fx12112 , fx22112 , fx11212 , & fx21212 , fx12212 , fx22212 , fxy1112 , fxy2112 , fxy1212 , fxy2212 , & fxyz112 , fxyz212 , fxyzq12 , fx11122 , fx21122 , fx12122 , fx22122 , & fx11222 , fx21222 , fx12222 , fx22222 , fxy1122 , fxy2122 , fxy1222 , & fxy2222 , fxyz122 , fxyz222 , fxyzq22 , fxyzqr1 , fxyzqr2 call dintrv ( me % x , x , me % ilox , ix ( 1 ), ix ( 2 ), mflag ) call dintrv ( me % y , y , me % iloy , iy ( 1 ), iy ( 2 ), mflag ) call dintrv ( me % z , z , me % iloz , iz ( 1 ), iz ( 2 ), mflag ) call dintrv ( me % q , q , me % iloq , iq ( 1 ), iq ( 2 ), mflag ) call dintrv ( me % r , r , me % ilor , ir ( 1 ), ir ( 2 ), mflag ) call dintrv ( me % s , s , me % ilos , is ( 1 ), is ( 2 ), mflag ) q1 = ( x - me % x ( ix ( 1 ))) / ( me % x ( ix ( 2 )) - me % x ( ix ( 1 ))) q2 = ( y - me % y ( iy ( 1 ))) / ( me % y ( iy ( 2 )) - me % y ( iy ( 1 ))) q3 = ( z - me % z ( iz ( 1 ))) / ( me % z ( iz ( 2 )) - me % z ( iz ( 1 ))) q4 = ( q - me % q ( iq ( 1 ))) / ( me % q ( iq ( 2 )) - me % q ( iq ( 1 ))) q5 = ( r - me % r ( ir ( 1 ))) / ( me % r ( ir ( 2 )) - me % r ( ir ( 1 ))) q6 = ( s - me % s ( is ( 1 ))) / ( me % s ( is ( 2 )) - me % s ( is ( 1 ))) p1 = one - q1 p2 = one - q2 p3 = one - q3 p4 = one - q4 p5 = one - q5 p6 = one - q6 fx11111 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 1 )) fx21111 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 1 )) fx12111 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 1 )) fx22111 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 1 )) fx11211 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 1 )) fx21211 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 1 )) fx12211 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 1 )) fx22211 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 1 )) fx11121 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 1 )) fx21121 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 1 )) fx12121 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 1 )) fx22121 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 1 )) fx11221 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 1 )) fx21221 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 1 )) fx12221 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 1 )) fx22221 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 1 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 1 )) fx11112 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 2 )) fx21112 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 1 ), is ( 2 )) fx12112 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 2 )) fx22112 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 1 ), is ( 2 )) fx11212 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 2 )) fx21212 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 1 ), is ( 2 )) fx12212 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 2 )) fx22212 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 1 ), is ( 2 )) fx11122 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 2 )) fx21122 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 1 ), ir ( 2 ), is ( 2 )) fx12122 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 2 )) fx22122 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 1 ), ir ( 2 ), is ( 2 )) fx11222 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 2 )) fx21222 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 1 ), iq ( 2 ), ir ( 2 ), is ( 2 )) fx12222 = p1 * me % f ( ix ( 1 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 1 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 2 )) fx22222 = p1 * me % f ( ix ( 1 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 2 )) + q1 * me % f ( ix ( 2 ), iy ( 2 ), iz ( 2 ), iq ( 2 ), ir ( 2 ), is ( 2 )) fxy1111 = p2 * ( fx11111 ) + q2 * ( fx21111 ) fxy2111 = p2 * ( fx12111 ) + q2 * ( fx22111 ) fxy1211 = p2 * ( fx11211 ) + q2 * ( fx21211 ) fxy2211 = p2 * ( fx12211 ) + q2 * ( fx22211 ) fxy1121 = p2 * ( fx11121 ) + q2 * ( fx21121 ) fxy2121 = p2 * ( fx12121 ) + q2 * ( fx22121 ) fxy1221 = p2 * ( fx11221 ) + q2 * ( fx21221 ) fxy2221 = p2 * ( fx12221 ) + q2 * ( fx22221 ) fxy1112 = p2 * ( fx11112 ) + q2 * ( fx21112 ) fxy2112 = p2 * ( fx12112 ) + q2 * ( fx22112 ) fxy1212 = p2 * ( fx11212 ) + q2 * ( fx21212 ) fxy2212 = p2 * ( fx12212 ) + q2 * ( fx22212 ) fxy1122 = p2 * ( fx11122 ) + q2 * ( fx21122 ) fxy2122 = p2 * ( fx12122 ) + q2 * ( fx22122 ) fxy1222 = p2 * ( fx11222 ) + q2 * ( fx21222 ) fxy2222 = p2 * ( fx12222 ) + q2 * ( fx22222 ) fxyz111 = p3 * ( fxy1111 ) + q3 * ( fxy2111 ) fxyz211 = p3 * ( fxy1211 ) + q3 * ( fxy2211 ) fxyz121 = p3 * ( fxy1121 ) + q3 * ( fxy2121 ) fxyz221 = p3 * ( fxy1221 ) + q3 * ( fxy2221 ) fxyz112 = p3 * ( fxy1112 ) + q3 * ( fxy2112 ) fxyz212 = p3 * ( fxy1212 ) + q3 * ( fxy2212 ) fxyz122 = p3 * ( fxy1122 ) + q3 * ( fxy2122 ) fxyz222 = p3 * ( fxy1222 ) + q3 * ( fxy2222 ) fxyzq11 = p4 * ( fxyz111 ) + q4 * ( fxyz211 ) fxyzq21 = p4 * ( fxyz121 ) + q4 * ( fxyz221 ) fxyzq12 = p4 * ( fxyz112 ) + q4 * ( fxyz212 ) fxyzq22 = p4 * ( fxyz122 ) + q4 * ( fxyz222 ) fxyzqr1 = p5 * fxyzq11 + q5 * fxyzq21 fxyzqr2 = p5 * fxyzq12 + q5 * fxyzq22 fxyzqrs = p6 * fxyzqr1 + q6 * fxyzqr2 end subroutine interp_6d","tags":"","loc":"proc/interp_6d.html","title":"interp_6d  finterp"},{"text":"private pure subroutine dintrv(xt, x, ilo, ileft, iright, mflag) Returns the indices in xt that bound x , to use for interpolation.\n  If outside the range, then the indices are returned that can\n  be used for extrapolation.\n  Precisely, if x < xt ( 1 ) then ileft = 1 , iright = 2 , mflag =- 1 if xt ( i ) <= x < xt ( i + 1 ) then ileft = i , iright = i + 1 , mflag = 0 if xt ( n ) <= x then ileft = n - 1 , iright = n , mflag = 1 History interv written by carl de boor [5] dintrv author: amos, d. e., (snla) : date written 800901 revision date 820801 Jacob Williams, 2/24/2015 : updated to free-form Fortran. Jacob Williams, 2/17/2016 : additional refactoring (eliminated GOTOs). Jacob Williams, 2/22/2016 : modified bspline-fortran dintrv routine for\n    linear interpolation/extrapolation use. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: xt a knot or break point vector real(kind=wp), intent(in) :: x argument integer, intent(inout) :: ilo an initialization parameter which must be set\n to 1 the first time the array xt is\n processed by dintrv. ilo contains information for\n efficient processing after the initial call and ilo must not be changed by the user.  each dimension\n requires a distinct ilo parameter. integer, intent(out) :: ileft left index integer, intent(out) :: iright right index integer, intent(out) :: mflag signals when x lies out of bounds Source Code dintrv Source Code pure subroutine dintrv ( xt , x , ilo , ileft , iright , mflag ) implicit none real ( wp ), dimension (:), intent ( in ) :: xt !! a knot or break point vector real ( wp ), intent ( in ) :: x !! argument integer , intent ( inout ) :: ilo !! an initialization parameter which must be set !! to 1 the first time the array `xt` is !! processed by dintrv. `ilo` contains information for !! efficient processing after the initial call and `ilo` !! must not be changed by the user.  each dimension !! requires a distinct `ilo` parameter. integer , intent ( out ) :: ileft !! left index integer , intent ( out ) :: iright !! right index integer , intent ( out ) :: mflag !! signals when `x` lies out of bounds integer :: ihi , istep , imid , n n = size ( xt ) ihi = ilo + 1 if ( ihi >= n ) then if ( x >= xt ( n ) ) then mflag = 1 ileft = n - 1 iright = n return end if if ( n <= 1 ) then mflag = - 1 ileft = 1 iright = 2 return end if ilo = n - 1 ihi = n endif if ( x >= xt ( ihi ) ) then ! now x >= xt(ilo). find upper bound istep = 1 do ilo = ihi ihi = ilo + istep if ( ihi >= n ) then if ( x >= xt ( n ) ) then mflag = 1 ileft = n - 1 iright = n return end if ihi = n elseif ( x >= xt ( ihi ) ) then istep = istep * 2 cycle endif exit end do else if ( x >= xt ( ilo ) ) then mflag = 0 ileft = ilo iright = ilo + 1 return end if ! now x <= xt(ihi). find lower bound istep = 1 do ihi = ilo ilo = ihi - istep if ( ilo <= 1 ) then ilo = 1 if ( x < xt ( 1 ) ) then mflag = - 1 ileft = 1 iright = 2 return end if elseif ( x < xt ( ilo ) ) then istep = istep * 2 cycle endif exit end do endif ! now xt(ilo) <= x < xt(ihi). narrow the interval do imid = ( ilo + ihi ) / 2 if ( imid == ilo ) then mflag = 0 ileft = ilo iright = ilo + 1 return end if ! note. it is assumed that imid = ilo in case ihi = ilo+1 if ( x < xt ( imid ) ) then ihi = imid else ilo = imid endif end do end subroutine dintrv","tags":"","loc":"proc/dintrv.html","title":"dintrv  finterp"},{"text":"private pure subroutine sort(dx, dy) Sorts an array dx in increasing order,\n  carrying along an additional array dy . Uses a non-recursive quicksort, reverting to insertion sort on arrays of\n  size <= 20. Dimension of stack limits array size to about 2&#94;32. License Original LAPACK license History Based on the LAPACK routine DLASRT . Extensively modified by Jacob Williams, Feb. 2016. Converted to\n    modern Fortran and added the dy output. Removed the descending sort option. Note This routine is not currently used in the module. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: dx on entry, the array to be sorted.\n on exit, dx has been sorted into increasing order\n ( dx(1) <= ... <= dx(n) ) or into decreasing order\n ( dx(1) >= ... >= dx(n) ), depending on id . real(kind=wp), intent(inout), dimension(:) :: dy array carried along with dx . Source Code sort Source Code pure subroutine sort ( dx , dy ) implicit none real ( wp ), dimension (:), intent ( inout ) :: dx !! on entry, the array to be sorted. !! on exit, `dx` has been sorted into increasing order !! (`dx(1) <= ... <= dx(n)`) or into decreasing order !! (`dx(1) >= ... >= dx(n)`), depending on `id`. real ( wp ), dimension (:), intent ( inout ) :: dy !! array carried along with `dx`. integer , parameter :: select = 20 !! max size for using insertion sort. integer :: endd , i , j , n , start , stkpnt real ( wp ) :: d1 , d2 , d3 , dmnmx , dmnmy , tmp integer , dimension ( 2 , 32 ) :: stack ! number of elements to sort: n = size ( dx ) if ( n > 1 ) then stkpnt = 1 stack ( 1 , 1 ) = 1 stack ( 2 , 1 ) = n do start = stack ( 1 , stkpnt ) endd = stack ( 2 , stkpnt ) stkpnt = stkpnt - 1 if ( endd - start <= select . and . endd > start ) then ! do insertion sort on dx( start:endd ) insertion : do i = start + 1 , endd do j = i , start + 1 , - 1 if ( dx ( j ) >= dx ( j - 1 ) ) cycle insertion dmnmx = dx ( j ) dx ( j ) = dx ( j - 1 ) dx ( j - 1 ) = dmnmx dmnmy = dy ( j ) dy ( j ) = dy ( j - 1 ) dy ( j - 1 ) = dmnmy enddo enddo insertion elseif ( endd - start > select ) then ! partition dx( start:endd ) and stack parts, largest one first ! choose partition entry as median of 3 d1 = dx ( start ) d2 = dx ( endd ) i = ( start + endd ) / 2 d3 = dx ( i ) if ( d1 < d2 ) then if ( d3 < d1 ) then dmnmx = d1 elseif ( d3 < d2 ) then dmnmx = d3 else dmnmx = d2 endif elseif ( d3 < d2 ) then dmnmx = d2 elseif ( d3 < d1 ) then dmnmx = d3 else dmnmx = d1 endif i = start - 1 j = endd + 1 do do j = j - 1 if ( dx ( j ) <= dmnmx ) exit end do do i = i + 1 if ( dx ( i ) >= dmnmx ) exit end do if ( i < j ) then tmp = dx ( i ) dx ( i ) = dx ( j ) dx ( j ) = tmp tmp = dy ( i ) dy ( i ) = dy ( j ) dy ( j ) = tmp else exit endif end do if ( j - start > endd - j - 1 ) then stkpnt = stkpnt + 1 stack ( 1 , stkpnt ) = start stack ( 2 , stkpnt ) = j stkpnt = stkpnt + 1 stack ( 1 , stkpnt ) = j + 1 stack ( 2 , stkpnt ) = endd else stkpnt = stkpnt + 1 stack ( 1 , stkpnt ) = j + 1 stack ( 2 , stkpnt ) = endd stkpnt = stkpnt + 1 stack ( 1 , stkpnt ) = start stack ( 2 , stkpnt ) = j endif endif if ( stkpnt <= 0 ) exit end do end if end subroutine sort","tags":"","loc":"proc/sort.html","title":"sort  finterp"},{"text":"private pure subroutine check_inputs(x, y, z, q, r, s, ierr) Uses: iso_fortran_env Check the validity of the inputs to the initialize routines.\n  Prints warning message if there is an error,\n  and also sets ierr (/=0 if there were any errors). Supports up to 6D: x,y,z,q,r,s History Jacob Williams, 2/24/2015 : Created this routine. Jacob Williams, 2/23/2016 : modified for linear interp module. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), optional dimension(:) :: x x abscissa vector real(kind=wp), intent(in), optional dimension(:) :: y y abscissa vector real(kind=wp), intent(in), optional dimension(:) :: z z abscissa vector real(kind=wp), intent(in), optional dimension(:) :: q q abscissa vector real(kind=wp), intent(in), optional dimension(:) :: r r abscissa vector real(kind=wp), intent(in), optional dimension(:) :: s s abscissa vector integer, intent(out) :: ierr 0 : no problems, 1 : x is not strictly increasing, 2 : y is not strictly increasing, 3 : z is not strictly increasing, 4 : q is not strictly increasing, 5 : r is not strictly increasing, 6 : s is not strictly increasing, Source Code check_inputs Source Code pure subroutine check_inputs ( x , y , z , q , r , s , ierr ) use iso_fortran_env , only : error_unit implicit none real ( wp ), dimension (:), intent ( in ), optional :: x !! `x` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: y !! `y` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: z !! `z` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: q !! `q` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: r !! `r` abscissa vector real ( wp ), dimension (:), intent ( in ), optional :: s !! `s` abscissa vector integer , intent ( out ) :: ierr !! `0` : no problems, !! `1` : `x` is not strictly increasing, !! `2` : `y` is not strictly increasing, !! `3` : `z` is not strictly increasing, !! `4` : `q` is not strictly increasing, !! `5` : `r` is not strictly increasing, !! `6` : `s` is not strictly increasing, ierr = 0 ! initialize if ( present ( x )) call check ( x , 1 , ierr ); if ( ierr /= 0 ) return if ( present ( y )) call check ( y , 2 , ierr ); if ( ierr /= 0 ) return if ( present ( z )) call check ( z , 3 , ierr ); if ( ierr /= 0 ) return if ( present ( q )) call check ( q , 4 , ierr ); if ( ierr /= 0 ) return if ( present ( r )) call check ( r , 5 , ierr ); if ( ierr /= 0 ) return if ( present ( s )) call check ( s , 6 , ierr ); if ( ierr /= 0 ) return contains !***************************************************************************************** pure subroutine check ( v , error_code , ierr ) implicit none real ( wp ), dimension (:), intent ( in ) :: v !! abcissae vector integer , intent ( in ) :: error_code !! error code for check integer , intent ( inout ) :: ierr !! will be set to `error_code` if there is a problem integer :: i !! counter integer :: n !! size of the input `v` array n = size ( v ) do i = 2 , n if ( v ( i ) <= v ( i - 1 )) then ierr = error_code exit end if end do end subroutine check end subroutine check_inputs","tags":"","loc":"proc/check_inputs.html","title":"check_inputs  finterp"},{"text":"function f1(x) 1d test function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Source Code f1 Source Code real ( wp ) function f1 ( x ) !! 1d test function implicit none real ( wp ), intent ( in ) :: x f1 = x + x + x + x + x + x end function f1","tags":"","loc":"proc/f1.html","title":"f1  finterp"},{"text":"function f2(x, y) 2d test function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value real(kind=wp) Source Code f2 Source Code real ( wp ) function f2 ( x , y ) !! 2d test function implicit none real ( wp ), intent ( in ) :: x , y f2 = x + y + x + y + x + y end function f2","tags":"","loc":"proc/f2.html","title":"f2  finterp"},{"text":"function f3(x, y, z) 3d test function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z Return Value real(kind=wp) Source Code f3 Source Code real ( wp ) function f3 ( x , y , z ) !! 3d test function implicit none real ( wp ), intent ( in ) :: x , y , z f3 = x + y + z + x + y + z end function f3","tags":"","loc":"proc/f3.html","title":"f3  finterp"},{"text":"function f4(x, y, z, q) 4d test function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q Return Value real(kind=wp) Source Code f4 Source Code real ( wp ) function f4 ( x , y , z , q ) !! 4d test function implicit none real ( wp ), intent ( in ) :: x , y , z , q f4 = x + y + z + q + x + y end function f4","tags":"","loc":"proc/f4.html","title":"f4  finterp"},{"text":"function f5(x, y, z, q, r) 5d test function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r Return Value real(kind=wp) Source Code f5 Source Code real ( wp ) function f5 ( x , y , z , q , r ) !! 5d test function implicit none real ( wp ), intent ( in ) :: x , y , z , q , r f5 = x + y + z + q + r + x end function f5","tags":"","loc":"proc/f5.html","title":"f5  finterp"},{"text":"function f6(x, y, z, q, r, s) 6d test function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(in) :: s Return Value real(kind=wp) Source Code f6 Source Code real ( wp ) function f6 ( x , y , z , q , r , s ) !! 6d test function implicit none real ( wp ), intent ( in ) :: x , y , z , q , r , s f6 = x + y + z + q + r + s end function f6","tags":"","loc":"proc/f6.html","title":"f6  finterp"},{"text":"Uses: iso_fortran_env Multidimensional linear interpolation/extrapolation. Uses repeated linear interpolation to evaluate\n  functions f(x), f(x,y), f(x,y,z), f(x,y,z,q), f(x,y,z,q,r), f(x,y,z,q,r,s) \n  which have been tabulated at the nodes of an n-dimensional rectangular grid.\n  If any coordinate  (x_i, y_i, ...)  lies outside the range of the corresponding\n  variable, then extrapolation is performed using the two nearest points. Variables one Abstract Interfaces destroy_func Derived Types linear_interp_class linear_interp_1d linear_interp_2d linear_interp_3d linear_interp_4d linear_interp_5d linear_interp_6d Functions check_if_unique Subroutines finalize_1d finalize_2d finalize_3d finalize_4d finalize_5d finalize_6d destroy_1d destroy_2d destroy_3d destroy_4d destroy_5d destroy_6d initialize_1d initialize_2d initialize_3d initialize_4d initialize_5d initialize_6d interp_1d interp_2d interp_3d interp_4d interp_5d interp_6d dintrv sort check_inputs Variables Type Visibility Attributes Name Initial real(kind=wp), private, parameter :: one = 1.0_wp numeric constant Abstract Interfaces abstract interface private pure elemental subroutine destroy_func (me) interface for bspline destructor routines Arguments Type Intent Optional Attributes Name class( linear_interp_class ), intent(inout) :: me Derived Types type, public, abstract :: linear_interp_class Base class for the linear interpolation types Type-Bound Procedures procedure(destroy_func), public :: destroy destructor type, public, extends( linear_interp_class ) :: linear_interp_1d Class for 1d linear interpolation. Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:), allocatable :: f real(kind=wp), private, dimension(:), allocatable :: x integer, private :: ilox = 1 Finalizations Procedures final :: finalize_1d","tags":"","loc":"module/linear_interpolation_module.html","title":"linear_interpolation_module  finterp"},{"text":"Uses: linear_interpolation_module iso_fortran_env Units test for 2d-6d linear interpolation. Variables nx ny nz nq nr ns x y z q r s fcn_1d fcn_2d fcn_3d fcn_4d fcn_5d fcn_6d s1 s2 s3 s4 s5 s6 tol rnd val tru err errmax fail i j k l m n idx idy idz idq idr ids iflag Functions f1 f2 f3 f4 f5 f6 Source Code linear_interpolation_test Variables Type Attributes Name Initial integer, parameter :: nx = 6 number of points in x integer, parameter :: ny = 6 number of points in y integer, parameter :: nz = 6 number of points in z integer, parameter :: nq = 6 number of points in q integer, parameter :: nr = 6 number of points in r integer, parameter :: ns = 6 number of points in s real(kind=wp) :: x (nx) real(kind=wp) :: y (ny) real(kind=wp) :: z (nz) real(kind=wp) :: q (nq) real(kind=wp) :: r (nr) real(kind=wp) :: s (ns) real(kind=wp) :: fcn_1d (nx) real(kind=wp) :: fcn_2d (nx,ny) real(kind=wp) :: fcn_3d (nx,ny,nz) real(kind=wp) :: fcn_4d (nx,ny,nz,nq) real(kind=wp) :: fcn_5d (nx,ny,nz,nq,nr) real(kind=wp) :: fcn_6d (nx,ny,nz,nq,nr,ns) type( linear_interp_1d ) :: s1 type( linear_interp_2d ) :: s2 type( linear_interp_3d ) :: s3 type( linear_interp_4d ) :: s4 type( linear_interp_5d ) :: s5 type( linear_interp_6d ) :: s6 real(kind=wp) :: tol real(kind=wp) :: rnd real(kind=wp), dimension(6) :: val real(kind=wp), dimension(6) :: tru real(kind=wp), dimension(6) :: err real(kind=wp), dimension(6) :: errmax logical :: fail integer :: i integer :: j integer :: k integer :: l integer :: m integer :: n integer :: idx integer :: idy integer :: idz integer :: idq integer :: idr integer :: ids integer, dimension(6) :: iflag Functions function f1 (x) 1d test function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) function f2 (x, y) 2d test function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y Return Value real(kind=wp) function f3 (x, y, z) 3d test function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z Return Value real(kind=wp) function f4 (x, y, z, q) 4d test function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q Return Value real(kind=wp) function f5 (x, y, z, q, r) 5d test function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r Return Value real(kind=wp) function f6 (x, y, z, q, r, s) 6d test function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(in) :: q real(kind=wp), intent(in) :: r real(kind=wp), intent(in) :: s Return Value real(kind=wp) Source Code program linear_interpolation_test use linear_interpolation_module use , intrinsic :: iso_fortran_env , only : wp => real64 implicit none integer , parameter :: nx = 6 !! number of points in x integer , parameter :: ny = 6 !! number of points in y integer , parameter :: nz = 6 !! number of points in z integer , parameter :: nq = 6 !! number of points in q integer , parameter :: nr = 6 !! number of points in r integer , parameter :: ns = 6 !! number of points in s real ( wp ) :: x ( nx ), y ( ny ), z ( nz ), q ( nq ), r ( nr ), s ( ns ) real ( wp ) :: fcn_1d ( nx ) real ( wp ) :: fcn_2d ( nx , ny ) real ( wp ) :: fcn_3d ( nx , ny , nz ) real ( wp ) :: fcn_4d ( nx , ny , nz , nq ) real ( wp ) :: fcn_5d ( nx , ny , nz , nq , nr ) real ( wp ) :: fcn_6d ( nx , ny , nz , nq , nr , ns ) type ( linear_interp_1d ) :: s1 type ( linear_interp_2d ) :: s2 type ( linear_interp_3d ) :: s3 type ( linear_interp_4d ) :: s4 type ( linear_interp_5d ) :: s5 type ( linear_interp_6d ) :: s6 real ( wp ) :: tol , rnd real ( wp ), dimension ( 6 ) :: val , tru , err , errmax logical :: fail integer :: i , j , k , l , m , n , idx , idy , idz , idq , idr , ids integer , dimension ( 6 ) :: iflag fail = . false . tol = 1.0e-14_wp do i = 1 , nx x ( i ) = dble ( i - 1 ) / dble ( nx - 1 ) end do do j = 1 , ny y ( j ) = dble ( j - 1 ) / dble ( ny - 1 ) end do do k = 1 , nz z ( k ) = dble ( k - 1 ) / dble ( nz - 1 ) end do do l = 1 , nq q ( l ) = dble ( l - 1 ) / dble ( nq - 1 ) end do do m = 1 , nr r ( m ) = dble ( m - 1 ) / dble ( nr - 1 ) end do do n = 1 , ns s ( n ) = dble ( n - 1 ) / dble ( ns - 1 ) end do do i = 1 , nx fcn_1d ( i ) = f1 ( x ( i )) do j = 1 , ny fcn_2d ( i , j ) = f2 ( x ( i ), y ( j )) do k = 1 , nz fcn_3d ( i , j , k ) = f3 ( x ( i ), y ( j ), z ( k )) do l = 1 , nq fcn_4d ( i , j , k , l ) = f4 ( x ( i ), y ( j ), z ( k ), q ( l )) do m = 1 , nr fcn_5d ( i , j , k , l , m ) = f5 ( x ( i ), y ( j ), z ( k ), q ( l ), r ( m )) do n = 1 , ns fcn_6d ( i , j , k , l , m , n ) = f6 ( x ( i ), y ( j ), z ( k ), q ( l ), r ( m ), s ( n )) end do end do end do end do end do end do ! initialize call s1 % initialize ( x , fcn_1d , iflag ( 1 )) call s2 % initialize ( x , y , fcn_2d , iflag ( 2 )) call s3 % initialize ( x , y , z , fcn_3d , iflag ( 3 )) call s4 % initialize ( x , y , z , q , fcn_4d , iflag ( 4 )) call s5 % initialize ( x , y , z , q , r , fcn_5d , iflag ( 5 )) call s6 % initialize ( x , y , z , q , r , s , fcn_6d , iflag ( 6 )) if ( any ( iflag /= 0 )) then do i = 1 , 6 if ( iflag ( i ) /= 0 ) then write ( * , * ) 'Error initializing ' , i , 'D interpolator. iflag=' , iflag ( i ) end if end do stop 1 end if ! compute max error at interpolation points errmax = 0.0_wp do i = 1 , nx call RANDOM_NUMBER ( rnd ); rnd = ( rnd - 0.5_wp ) / 10 0.0_wp call s1 % evaluate ( x ( i ) + rnd , val ( 1 )) tru ( 1 ) = f1 ( x ( i ) + rnd ) err ( 1 ) = abs ( tru ( 1 ) - val ( 1 )) errmax ( 1 ) = max ( err ( 1 ), errmax ( 1 )) do j = 1 , ny call RANDOM_NUMBER ( rnd ); rnd = rnd / 10 0.0_wp call s2 % evaluate ( x ( i ) + rnd , y ( j ) + rnd , val ( 2 )) tru ( 2 ) = f2 ( x ( i ) + rnd , y ( j ) + rnd ) err ( 2 ) = abs ( tru ( 2 ) - val ( 2 )) errmax ( 2 ) = max ( err ( 2 ), errmax ( 2 )) do k = 1 , nz call RANDOM_NUMBER ( rnd ); rnd = rnd / 10 0.0_wp call s3 % evaluate ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , val ( 3 )) tru ( 3 ) = f3 ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd ) err ( 3 ) = abs ( tru ( 3 ) - val ( 3 )) errmax ( 3 ) = max ( err ( 3 ), errmax ( 3 )) do l = 1 , nq call RANDOM_NUMBER ( rnd ); rnd = rnd / 10 0.0_wp call s4 % evaluate ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , q ( l ) + rnd , val ( 4 )) tru ( 4 ) = f4 ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , q ( l ) + rnd ) err ( 4 ) = abs ( tru ( 4 ) - val ( 4 )) errmax ( 4 ) = max ( err ( 4 ), errmax ( 4 )) do m = 1 , nr call RANDOM_NUMBER ( rnd ); rnd = rnd / 10 0.0_wp call s5 % evaluate ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , q ( l ) + rnd , r ( m ) + rnd , val ( 5 )) tru ( 5 ) = f5 ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , q ( l ) + rnd , r ( m ) + rnd ) err ( 5 ) = abs ( tru ( 5 ) - val ( 5 )) errmax ( 5 ) = max ( err ( 5 ), errmax ( 5 )) do n = 1 , ns call RANDOM_NUMBER ( rnd ); rnd = rnd / 10 0.0_wp call s6 % evaluate ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , q ( l ) + rnd , r ( m ) + rnd , s ( n ) + rnd , val ( 6 )) tru ( 6 ) = f6 ( x ( i ) + rnd , y ( j ) + rnd , z ( k ) + rnd , q ( l ) + rnd , r ( m ) + rnd , s ( n ) + rnd ) err ( 6 ) = abs ( tru ( 6 ) - val ( 6 )) errmax ( 6 ) = max ( err ( 6 ), errmax ( 6 )) end do end do end do end do end do end do ! check max error against tolerance do i = 1 , 6 write ( * , * ) i , 'D: max error:' , errmax ( i ) if ( errmax ( i ) >= tol ) then write ( * , * ) ' ** test failed ** ' else write ( * , * ) ' ** test passed ** ' end if write ( * , * ) '' end do contains real ( wp ) function f1 ( x ) !! 1d test function implicit none real ( wp ), intent ( in ) :: x f1 = x + x + x + x + x + x end function f1 real ( wp ) function f2 ( x , y ) !! 2d test function implicit none real ( wp ), intent ( in ) :: x , y f2 = x + y + x + y + x + y end function f2 real ( wp ) function f3 ( x , y , z ) !! 3d test function implicit none real ( wp ), intent ( in ) :: x , y , z f3 = x + y + z + x + y + z end function f3 real ( wp ) function f4 ( x , y , z , q ) !! 4d test function implicit none real ( wp ), intent ( in ) :: x , y , z , q f4 = x + y + z + q + x + y end function f4 real ( wp ) function f5 ( x , y , z , q , r ) !! 5d test function implicit none real ( wp ), intent ( in ) :: x , y , z , q , r f5 = x + y + z + q + r + x end function f5 real ( wp ) function f6 ( x , y , z , q , r , s ) !! 6d test function implicit none real ( wp ), intent ( in ) :: x , y , z , q , r , s f6 = x + y + z + q + r + s end function f6 end program linear_interpolation_test","tags":"","loc":"program/linear_interpolation_test.html","title":"linear_interpolation_test  finterp"}]}